## make sure I can change the AST representation whenver I feel like it.
## verl's meta-module doesn't support import.


(module serl)

(import scompile
	error
	lineno
	curmod is_curmod
	transform
	transform_each
	map_env0
	genvar
	gensym
	)

(import lists
	map 
	foldl
	foldr
	reverse
	member
	foreach
	)

# (export ast-tag ast-line ast-mod ast-data
# 	upto-block
# 	atom-cat
# 	erlpp ## TODO: remove when eval-only is implemented
# 	output-forms ## TODO: remove later when verl is removed.
# 	)

(export-from
 (specials ast-as-is)
 (macros defasts))

(export-from
 (functions
  erl-ast-of
  ast-tag ast-line ast-mod ast-data
  upto-block split-tail 
  atom-cat
  erlpp		     ## TODO: remove when eval-only is implemented
  output-forms	     ## TODO: remove later when verl is removed.
  )
 (specials
  %a{__eof} %a{__bof}
  %a{__block} %a{__brace}
  %a{__integer} %a{__float} %a{__string}
  %a{__atom} %a{__var}
  %a{__quote} %a{__bquote}
  quote
  module
  def defm defspecial
  functions-import functions-export functions-output
  #macros-import
  macros-export macros-output
  #specials-import
  specials-export specials-output
  eval-binding
  let lsc
  letf
  fn call 
  case if
  do toplevel
  try receive
  bin
  tuple cons
  )
 (macros
  export-from import-from
  export import 
  let* >>
  begin
  ls
  ))

# (export-from
#  (macros
#   integer float
#   atom var
#   string
#   paren brace block
#   ))


## export this so it's usable by future bootstraps.
## this is a piece of ad hocery.
(export-from
 (macros def-ops))

(export-from
 (specials
  + - * / ++ --
  == /= =< < >= >
  div rem
  bnot band bor bxor bsl bsr
  === /==
  and or xor orelse andalso
  not))



# (def cat (L1 :opt L2):
#   (case L2
#     (false (lists\append L1))
#     (_ (lists\append L1 L2))))

# (def fmt (Str Args):
#   (io\format Str Args))

##################################################
# .Helper


(def erl-ast-of (Term):
  (erl_syntax\revert (erl_syntax\abstract Term)))

(def ast-tag (Ast):eval: (erlang\element 1 Ast))
(def ast-line (Ast):eval: (erlang\element 2 Ast))
(def ast-mod (Ast):eval: (erlang\element 3 Ast))
(def ast-data (Ast):eval: (erlang\element 4 Ast))

## this is useful for certain special macros when parts of it had
## already been expanded.
(defspecial ast-as-is (Ast) _Env:
  Ast)


(defm defasts (:all Names):
  `(toplevel
    ;(lsc Name Names:
	  (let Tag (let (atom A) Name:
			(atom (list-to-atom (cat "__" (atom-to-list A))))): 
	       `(defm ,Name (:all Args):
		  (case Args
		    ([Data] `{,',Tag ,(integer (lineno)) ,(atom (curmod)) ,Data})
		    ([Data Line] `{,',Tag ,Line ,(atom (curmod)) ,Data})
		    ([Data Line Module] `{,',Tag ,Line ,Module ,Data})
		    ))
	       ))))

(defasts
    integer float
    atom var
    string
    paren brace block
    )

(def pr (Term):
  (fmt "~p\n" [Term])
  Term)

(def erlpp (Ast):eval:
     (fmt "~s\n" [(erl_pp\expr Ast)]))

(def upto-block (Es):eval:
  (let {UpToFirstBlock Rest} (lists\splitwith
			      (fn (E)
				  (case E
				    ((block _) false)
				    (_ true)))
			      Es):
       {UpToFirstBlock Rest}
       ))

(def split-tail (Lst):eval:
  (reverse Lst ~>> [Tail|RHeads] {(reverse RHeads) Tail}))

(def atom-cat (Vs):eval:
     ## perhaps name it catom?? 
  (foldl
   (fn (V Acc)
       (let Str (if (erlang\is_integer V) (erlang\integer_to_list V)
		    (erlang\is_atom V) (erlang\atom_to_list V)
		    (erlang\is_list V) V):
	    [Str|Acc]))
   [] Vs
   .reverse ~string\join "-" .erlang\list_to_atom))


#\with-genvar

(defm with-genvar (:etc Vars :etc Body): 
  `(let ;(lists\foldl
	  (fn (Var Acc) [Var '(scompile\genvar)|Acc])
	  []
	  Vars):
     ;Body
     ))



#\clause
(def clause (Ps GSeq Es Env):eval:
  (let* L (let [P|_] Ps: (ast-line P))
	{Env Ps} (verl\patterns Ps (scompile\lexical_shadow Env vars []))
	:
	{clause L Ps 
		(guard-seq GSeq Env)
		(transform_each Es Env)}
       ))

(def guarded-clause (Ps GuardedBody Env):eval:
  ## a guarded body is a sequence of expression possibly preceded by test blocks.
  (case GuardedBody
    ##  (... : <guard-test>* : <guard-test>* : ... : <exp>*)
    ((== [(block _)|_] Es)
     (let {GSeq (block Body)} (split-tail Es):
	  (clause Ps GSeq Body Env)))
    ## (... <exp>* )
    (Body
     (clause Ps [] Body Env)
      ##(verl\clause [P] [] Es (ast-line P) Env)
      )))

# A guard sequence Gs is a sequence of guards. The guard sequence is true if at least one of the guards is true. 
# A guard is a sequence of guard expressions. The guard is true if all guard expressions evaluate to true. 

# A guard sequence Gs is a sequence of guards G_1; ...; G_k, and Rep(Gs) = [Rep(G_1), ..., Rep(G_k)]. If the guard sequence is empty, Rep(Gs) = []. 

# A guard G is a nonempty sequence of guard tests Gt_1, ..., Gt_k, and Rep(G) = [Rep(Gt_1), ..., Rep(Gt_k)].

(def guard-seq (GSeq Env):eval:
     ##(fmt "Gseq: ~p\n" [GSeq])
  (lsc (block Guard) GSeq:
       (lsc Test Guard:
	    (let Ast (transform Test Env):
		 (case (erl_lint\is_guard_test Ast)
		   (true Ast)
		   (false (error "Invalid guard: ~p" [Ast])))))))


##################################################
# .Pseudo Forms

(def cleanup ():eval: 
     (ets\delete serl-info)
     ok)

(defspecial %a{__bof} () _Env:
  (ets\new serl-info [named_table])
  0)

(def pr-f-defs (Fs):
  (case Fs
    ([] (fmt "done\n"))
    ([F|Fs]
     (fmt "Size:~p\n" [(term-to-binary F .size)])
     (pr-f-defs Fs))
    ))

(defspecial %a{__eof} (Command) Env:
  (case Command
    (normal (let R (verl\emit (output-forms Env) Env
			      (verl\set_opts (scompile\options))):
		 ##(fmt "ETS: ~p\n" [(ets\info serl-info)])
		 ##(fmt "memory: ~p\n" [(erlang\process_info (self) memory)])
		 ##(fmt "Env size: ~p\n" [(term-to-binary (scompile\env) .size)])
		 ##(fmt "Env: ~p\n" [Env])
		 R
		 ))
    (after (cleanup))))

(def output-forms (Env):eval:
  ## do output for each NS types
  (let* Types (lsc {Type _} (env\assoc Env [definitions] ~>>
				       {ok NSs} NSs):
		   Type):
	(foldl (fn (Type {Info Headers Bodies})
		   ## transform (<Type>-output) for each namespace
		   (transform `(,(atom (atom-cat: Type output)) ,Info) Env
			      ~>> {I H B} {I [H|Headers] [B|Bodies]}))
	       {(env\new) [] []}
	       Types
	       ~>> {Info Headers Bodies}
		(let* Info (env\assoc_put Info [imports]
					  (env\assoc Env [imports]
						     ~>> {ok Imports} Imports))
		      Info (env\assoc_put Info [base]
					  (env\assoc Env [base] ~>> {ok Base}
						     (lsc {M _Defs} Base: M))):
		  (lists\flatten [{attribute 0 module (curmod)}
				  {attribute 0 serl true}
				  {attribute 0 serl_info Info}
				  Headers Bodies])
		  ))))



#\asts

# the payload of the ast is passed in.
(defspecial %a{__block} (Es) Env:
  (transform `(ls: ;(ast-data Es)) Env))

(defspecial %a{__brace} (Es) Env: 
  (transform `(tuple: ;(ast-data Es)) Env))

(defspecial %a{__integer} (V) _Env:
  {integer (lineno) (ast-data V)})

(defspecial %a{__float} (V) _Env:
  {float (lineno) (ast-data V)})

(defspecial %a{__string} (V) _Env:
  {string (lineno) (ast-data V)})

(defspecial %a{__atom} (V) _Env:
  {atom (lineno) (ast-data V)})

(defspecial %a{__var} (V) Env:
  (let {_ L M A} V:
       (case A
	 (%a{_} {var L A})
	 (_ (case (scompile\lookup Env vars {M A})
	      ({ok Alias} {var L Alias})
	      (false {var L A})
	      )))))

(defspecial %a{__quote} (V) _Env:
  (erl_syntax\abstract (ast-data V) .erl_syntax\revert))

(defspecial %a{__bquote} (V) Env:
  (transform (bq\completely_expand (ast-data V)) Env))

(defspecial quote (V) _Env:
  (erl_syntax\abstract V .erl_syntax\revert))


##################################################
# 1. Environment
#
# Just support functions & macros/specials for the moment.

## (export "sp-.*")
## (export "mac-.*")

# (import-from mod (macros ...) (functions ...))

(defspecial module (Mod) _Env:
  (case (is_curmod Mod)
    (true 1)
    (false (error "Module name mismatch: ~p" [Mod])))) 

(def export-defs (Type Names):eval:
  (let Env (env\assoc_append (scompile\env) [exports Type] Names):
       (scompile\set_env Env)
       Env))

(def get-exports (Env Type):eval: 
  (env\assoc Env [exports Type] ~case
	     ({ok Names} Names)
	     (_ [])))

# (def get-imports (Env Type):eval:
#      (let Names (env\assoc Env [imports] ~>> {ok Imports}
# 			   (lsc {Mod _} Imports
# 				Name (env\assoc [imports Mod Type] ~>> {ok }
# 						)
# 				: Mod)):
# 	  Namess (lsc Mod Mods
# 		      Val (env\imports_of Mod Type all ~>> {Type Vals}):
# 		      )
# 	  ))


(def new-def (NSType Name Def Info):eval:
  (case (ets\insert_new serl-info {{definitions NSType Name} Info})
    (false (error "%s already defined in %s" [Name NSType]))
    (_ (let Env (env\assoc_put (scompile\env) [definitions NSType Name] Def):
	    (scompile\set_env Env)
	    Env))))

(def def-info (_Env NSType Name Key):eval:
  # caller of this function should check its result
  (case (ets\match serl-info {{definitions NSType Name} %a{$1}})
    ([[Info]] (proplists\lookup Key Info ~case
				(none false)
				({_ R} {ok R})))
    (_ false)))

# (def get-def (Env NSType Name):eval:
#   # get the definition of a name
#   (env\assoc Env [definitions NSType Name] ~case
# 	     ({ok Def} Def)
# 	     (_ false)))

(def get-defs (Env NSType):eval:
  # get all the definitions related to a namespace
  (env\assoc Env [definitions NSType] ~case
	     ({ok Defs} Defs)
	     (false [])))


#\import-from
(defm import-from (:etc Mod Specs):
  `(toplevel
    ;(lsc `(,(atom Type) ;Names) Specs:
	  `(,(atom (atom-cat: Type import)) ,Mod ;Names)
	  )))


# (export-from (functions a b c) (macros c d e)) ## =>
# (toplevel
#  (functions-export a b c)
#  (macros-export c d e))

#\export-from
(defm export-from (:etc Specs):
  `(toplevel
    ;(lsc `(,(atom Type) ;Names) Specs:
	  `(,(atom (atom-cat: Type export)) ;Names)
	  )))

#\import
(defm import (:etc Mod Names):
  `(functions-import ,Mod ;Names))

(defspecial functions-import (:etc Mod Names) Env:
  (let (atom Mod) Mod
       Names (lsc (atom A) Names: A):
       (foreach (fn (Name)
		    (case (scompile\lookup Env functions {(curmod) Name})
		      ({ok {{M A}}} (error "Function import conflict: ~p:~p with ~p:~p"
					   [Mod Name M A]))
		      (_ ok)))
		Names)
       ##TODO allow importing functions from not yet loaded modules
       (let Env (env\import Env Mod functions Names):
	    (scompile\set_env Env)
	    2)
       ))

#\export
(defm export (:etc Mod Names):
  `(functions-export ,Mod ;Names))

#If F is an attribute -export([Fun_1/A_1, ..., Fun_k/A_k]), then Rep(F) = {attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}.

(defspecial functions-export (:etc Names) _Env: 
  (export-defs functions Names)
  2)

(defspecial functions-output (Info) Env:
  (output-fun Info Env functions))



(defspecial macros-export (:etc Names) _Env:
  (export-defs macros Names)
  2)

(defspecial macros-output (Info) Env:
  (output-meta-fun Info Env macros))



(defspecial specials-export (:etc Names) _Env:
  (export-defs specials Names)
  2)

(defspecial specials-output (Info) Env:
  (output-meta-fun Info Env specials))



(def output-fun (Info Env Type):eval:
  ## used so far by functions
     ##(fmt "output: ~p\n" [Type])
  (let* FNames (lsc {Name _} (get-defs Env Type):
		    Name)
	Exports (lsc Export (get-exports Env Type): 
		     {(ast-line Export)
		      (ast-data Export)
		      })
	Info (env\assoc_put
	      Info [exports Type]
	      (let M (curmod):
		   (lsc {Line Name} Exports:
			{Name {{M Name}
			       [{doc
				 (def-info Env Type Name doc ~case
					   ({ok Doc} Doc)
					   (_ (error "~p: Exporting ~p undefined: ~p"
						     [Line Type Name])))
				 }]}})))
	Defs (lsc Name FNames :
		  {Name (def-info Env Type Name asts ~case
				  ({ok Arity-Ast*} Arity-Ast*)
				  (false (error "no asts in def-info??")))})
	:
	{Info
	 ##export attributes
	 (lsc {Line Name} Exports
	      {Arity _Ast} (lists\keysearch Name 1 Defs ~>>
					    {value {_Name R}} R):
	      {attribute Line export [{Name Arity}]}
	      )
	 ##definitions
	 (lsc Name FNames
	      {_Arity Ast} (lists\keysearch Name 1 Defs ~>>
					    {value {_Name R}} R):
	      Ast)
	 }))

(def output-meta-fun (Info Env Type):eval:
  ## shared by exports,specials
  ## only the exported defs need actually be output
     ##(fmt "output-meta: ~p\n" [Type])
  (let* Exports (lsc Export (get-exports Env Type):
		     {(ast-line Export) (ast-data Export)})
	{Headers Bodies}
	(lsc {Line Name} Exports:
	     (let* MacName (def-info Env Type Name name ~case
				     ({ok Name} Name)
				     (_ (error "~p: Exporting ~p undefined: ~p"
					       [Line Type Name])))
		   Attributes (lsc Arity (def-info Env Type Name arities ~>>
						   {ok Arities} Arities):
				   {attribute Line export [{MacName Arity}]})
		   Ast (def-info Env Type Name ast ~case
				 ({ok Ast} Ast)):
		   {Attributes Ast})
	     .lists\unzip)
	Info
	(env\assoc_put Info [exports Type]
		       (lsc {_L Name} Exports:
			    {Name {## Fun
				   {(curmod) (def-info Env Type Name name ~>>
						       {ok MacName} MacName)}
				   ## Info
				   [{doc (def-info Env Type Name doc ~>>
						   {ok Doc} Doc)}]}}))
	:
	##(fmt "Info: ~p\n" [Info])
	{Info 
	 ## export attributes
	 (lists\flatten Headers)
	 ## definitions
	 Bodies})) 




##################################################
# .Definitions

(def macro-parse-args (Args Body VAll):eval:
  # V_n are the continuaton variables that store partial parsing results.
  # parse the required args or a leading :etc block (special case).
  # auxiliary args must come after the leading args.
     #(fmt "MPA:\nBody: ~p\n" [Body])
  (case Args
    ([] `(let (paren [_Car]) ,VAll : ;Body))
    ([(block ['etc|EArgs])|Blocks]
     (let {Heads Tail} (split-tail EArgs)
	  VK (genvar) VK2 (genvar)
	  :
	  `(let* (paren [_Car ;Heads | ,VK]) ,VAll
		 {,Tail ,VK2} (upto-block ,VK)
		 : ,(macro-arg-blocks Blocks Body VAll VK2))))
    ([(block ['all|Args])]
     (let {Heads Tail} (split-tail Args):
	  `(let (paren [_ ;Heads | ,Tail]) ,VAll:
		;Body)
	  ))
    (_ (let* {Heads Blocks} (upto-block Args)
	     VK (genvar)
	     :
	     `(let (paren [_Car ;Heads | ,VK]) ,VAll
		   : ,(macro-arg-blocks Blocks Body VAll VK))
	     ))))

(def macro-arg-blocks (Blocks Body VAll VK):eval:
    (let* {Blocks AuxBlocks} (lists\partition
				 (fn ((block [(atom Type) | _]))
				     ## raise error if type not recognized
				     (case Type
				       (etc true)
				       (tag true)
				       ##(aux false)
				       (_ (error "Unrecognized macro argument block: ~p"
						 [Type]))))
				 Blocks) 
	  AuxBindings (macro-aux-blocks AuxBlocks VAll)
	  :
	  (case Blocks
	    ([] `(let ;AuxBindings : ,(macro-arg-end Body VK)))
	    (_ `(let ;AuxBindings
		  : ,(macro-arg-blocks-2 Blocks Body VK)))
	    #~>> R (fmt "MAB -> ~p\n" [R]) R
	     )))

(def macro-arg-blocks-2 (Blocks Body VK):eval:
  # parse the non-auxiliary block args
  # key & etc
  (case Blocks
    ([] (macro-arg-end Body VK))
    ([(block [(atom Type)|Args])|Blocks]
     (case Type
       (etc (let VK2 (genvar)
		 EtcBinding (case Args
			      ([Tail] Tail)
			      ## more than two args in :etc
			      ([_ _|_] (reverse Args ~>> [Tail|RHeads]
					  `[;(reverse RHeads)|,Tail]))) 
		 :
		 `(let [(block ,EtcBinding)|,VK2] ,VK
		       : ,(macro-arg-blocks-2 Blocks Body VK2))))
       (tag (let* [Tag TagSpec] Args
		  {TagArg Default} (case TagSpec
				     (`(,Arg ,Val) {Arg Val})
				     (Arg {Arg '[]}))
		  VK2 (genvar) 
		  :
		  `(let {,TagArg ,VK2} (case ,VK
					 ([(block [(atom ,Tag)|TagVal])|Blocks]
					  {TagVal Blocks})
					 (Args {,Default Args})):
			,(macro-arg-blocks-2 Blocks Body VK2))
		  ))
       ))))

(def macro-aux-blocks (Blocks _VAll):eval:
     (case Blocks
       ([] [])
       (_ (error "No auxiliary argument supported yet") ))
  # auxiliary arguments that don't consume arguments.
     
#      (foldl (fn ((block [Type|Spec]) Bindings)
# 	     (case Type
# 	       ('all [(>> Spec [AllArg] AllArg) VAll | Bindings])))
# 	 []
# 	 Blocks) 
  )

(def macro-arg-end (Body VK):eval:
     `(case ,VK
	([] ;Body)
	(_  (erlang\error {macro-arg "Leftover arguments."}))))

# returns list of [{Args Body} ...]
(def fun-args (Name Args Body):eval:
  (let {RequiredArgs Blocks} (upto-block Args):
       (case Blocks
	 ([]
	  [{RequiredArgs `(begin ;Body)}])
	 ##( ... :opt ...)
	 ([(block ['opt | OptArgs])]
	  (fun-args-opts Name RequiredArgs OptArgs Body))
	 (_
	  (error "def block args not yet supported")
	  #(fun-args-blocks Name RequiredArgs Blocks Body)
	  ))))

(def fun-args-opts (Name Reqs Opts Body):eval:
     (let Opts (lsc Opt Opts:
		    (case Opt
		      (`(,Arg ,Init) [Arg Init])
		      (Arg [Arg 'false])))
	  :
	  (fun-args-opt-rec Name Reqs [] Opts Body [])))


# (def foo (A B :opt (C c) (D d)): ...)
#
# (foo A B)
#  (let C c D d: (foo A B C D))
# (foo A B C)
#  (let D d: (foo A B C D))
# (foo A B C D)
#   body
#
# damn! I need flet
(def fun-args-opt-rec (Name Reqs OptsBound OptsUnbound Body Acc):eval:
  (case OptsUnbound
    ([]
     [{(cat Reqs (lsc [Arg _] (reverse OptsBound): Arg))
       `(begin ;Body)}
      |Acc])
    ([OU|OUs]
     ## fugly
     (fun-args-opt-rec
      Name Reqs [OU|OptsBound] OUs Body
      [{(cat Reqs (lsc [Arg _] (reverse OptsBound): Arg))
	`(let* ;(cat OptsUnbound):
	   (,Name ;Reqs
		  ;(lsc [Arg|_] OptsBound: Arg)
		  ;(lsc [Arg|_] OptsUnbound: Arg)))}
       
	|Acc]
      ))))

#(def fun-args-blocks ():e)


# (def fun-args-blocks (Name Reqs Blocks Body):eval:
#   ()
#   )

# If E is case E_0 of Cc_1 ; ... ; Cc_k end, where E_0 is an expression and each Cc_i is a case clause then Rep(E) = {'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}.

(def make-def (FName FClauses Env):
  ## take care to do transform only once.
  ## FClauses==[{Args Body} ...], where Body is a single expression.
  (let* (atom Name Line _) FName
	EvalVarName (gensym)
	Arity-Args-Body*
	(lsc {Args Body} FClauses:
	     (let* {Env Args} (verl\patterns Args Env)
		   Body (transform Body Env):
		   {(length Args) Args Body}))
	EvalAst {case Line {var Line EvalVarName}
		      (lsc {_Arity Args Body} Arity-Args-Body*:
			   (let Args (erl_syntax\list Args none
						      .erl_syntax\revert):
				{clause Line [Args] [] [Body]}))}
	EvalFn (fn (Args Env)
		   ## the environment at the time of call is passed in.
		   (scompile\eval_erl EvalAst [{EvalVarName Args}] Env ~>>
				      {Result _} Result))
	Arity-Def*
	(lsc {Arity Args Body} Arity-Args-Body*:
	     {Arity
	      {function Line Name Arity
			[{clause Line Args [] [Body]}]}}) 
	: 
	{{EvalFn} Arity-Def*}))


#\def
(defspecial def ((== FName (atom Name)) `(;Args)
		 :tag doc Doc
		 :tag eval Eval
		 :etc Body) Env:
  (fmt "def: ~p\n" [Name])
  ##(fmt "args: ~p\n" [Args])
  ##(fmt "def arities:\n~p\n" [(fun-args FName Args Body)])
  (let* EvalFlag (case Eval (false false) (_ true))
	Doc (case Doc (false "") (_ Doc))
	#Mod (curmod)
	FClauses (fun-args FName Args Body) ## [{Args Body} ...], where Body is a single expression.
	{EvalFn Arity-Def*} (make-def FName FClauses Env)
	Info [{asts Arity-Def*}
	      {doc Doc}
	      {eval EvalFlag}]
	:
	(new-def functions Name EvalFn Info)
	10
	))


#\defm
(defspecial defm ((atom Name) `(;Args)
		       :tag doc Doc
			:etc Body) Env:
  (fmt "defm: ~p\n" [Name])
  (let* Doc (case Doc (false "") (_ Doc))
	Line (lineno)
	#the variable for the whole macro expression
	VAllName (gensym)
	VAll (var VAllName)
	#the actual name to define the macro function
	MacName (atom-cat: "$mac" Name)
	# take care to transform the body only once
	MacBody (macro-parse-args Args Body VAll
				  ~transform Env)
	## the macro function interprets the erl-ast of the macro definition
	## the macro function closes over the current  meta-environment.
	## the macro is not visible to its own definition.
	## ## but the macro /can/ be used recursively.
	## functions defined after the macro are not visible.
	## ## I think this is sensible... 
	EvalAst MacBody 
	EvalFn (fn (InputAst Env) 
		   (scompile\eval_erl EvalAst [{VAllName InputAst}] Env ~>>
				      {Result _} Result))
	DefAst {function Line MacName 1
			 [{clause Line [{var Line VAllName}] [] [MacBody]}]}
	Info [{ast DefAst}
	      {arities [1]}
	      {name MacName}
	      {args Args} 
	      {doc Doc}]
	:
	(new-def macros Name {EvalFn} Info)
	10))


#\defspecial
(defspecial defspecial ((atom Name) `(;Args) VEnv
		       :tag doc Doc
			:etc Body) Env :
  (fmt "defspecial: ~p\n" [Name])
  (let* Doc (case Doc (false "") (_ Doc))
	Line (lineno)
	#the variable for the whole macro expression
	VAllName (gensym)
	VAll (var VAllName)
	#the variable for the environment during expansion
	#VEnv
	VEnvName (let (var Atom) VEnv: Atom) 
	#the actual name to define the macro function
	MacName (atom-cat: "$special" Name) 
	MacBody (macro-parse-args Args Body VAll
				  ~transform Env)
	EvalAst MacBody 
	EvalFn (fn (Ast Env)
		   (let {Result _} (scompile\eval_erl EvalAst [{VAllName Ast}
							       {VEnvName Env}]
						      Env):
			Result))
	DefAst {function Line MacName 2
			 [{clause Line
				  [{var Line VAllName}
				   {var Line VEnvName}]
				  []
				  [MacBody]}]}
	Info [{ast DefAst}
	      {arities [2]}
	      {name MacName}
	      {args Args} 
	      {doc Doc}]
	: 
	(new-def specials Name
		 {EvalFn} Info)
	10))


##################################################
# .Binding Forms

(defspecial eval-binding (V) _Env: 
    (let L (lineno):
	 (case V
	   ((atom A) {var L A})
	   ((var A) {var L A}))))

(def let-bindings (Bindings Patterns Assignments):eval:
     (case Bindings
       ([] {(reverse Patterns) (reverse Assignments)})
       ([Pattern Value|Bindings]
	(let-bindings Bindings [Pattern|Patterns] [{Pattern Value}|Assignments]))))

#\let*
(defm let* (:etc Bindings :etc Body):
  (case Bindings
    ([] `(begin ;Body))
    ([Pattern Value|Bindings] `(let ,Pattern ,Value: (let* ;Bindings: ;Body)))))

#\let 
(defspecial let (:etc Bindings :etc Body) Env:
  (let* Line (lineno) 
	{Patterns Assignments} (let-bindings Bindings [] []) 
	Env2 (verl\binds Patterns (scompile\lexical_shadow Env vars []))
	Assignments
	(lsc {P V} Assignments:
	     {match (ast-line P)
		    (verl\gen_pat P Env2) # pattern generated with new bindings
		    (transform V Env)} # value evaluated with old environment
	     ) 
	: 
	{block Line (cat Assignments (transform_each Body Env2))}))

#\>>
(defm >> (:etc Val Pattern Body):
  `(let ,Pattern ,Val: ;Body))


# If E is case E_0 of Cc_1 ; ... ; Cc_k end, where E_0 is an expression and each Cc_i is a case clause then Rep(E) = {'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}.

#\case
(defspecial case (:etc E Cs) Env:
  (let Line (lineno): 
       {case Line
	 (transform E Env) 
	 (lsc `(,P ;GBody) Cs:
	      (guarded-clause [P] GBody Env))}))




# # If C is a catch clause P -> B where P is a pattern and B is a body, then Rep(C) = {clause,LINE,[Rep({throw,P,_})],[],Rep(B)}. 
# # If C is a catch clause X : P -> B where X is an atomic literal or a variable pattern, P is a pattern and B is a body, then Rep(C) = {clause,LINE,[Rep({X,P,_})],[],Rep(B)}. 
# # If C is a catch clause P when Gs -> B where P is a pattern, Gs is a guard sequence and B is a body, then Rep(C) = {clause,LINE,[Rep({throw,P,_})],Rep(Gs),Rep(B)}. 
# # If C is a catch clause X : P when Gs -> B where X is an atomic literal or a variable pattern, P is a pattern, Gs is a guard sequence and B is a body, then Rep(C) = {clause,LINE,[Rep({X,P,_})],Rep(Gs),Rep(B)}.

(def catch-clause (`(;Es) Env):eval:
     (let {Heads Blocks} (upto-block Es)
	  #L (lineno)
	  :
	  (case Blocks
	    ## (<pattern> <exp>*)
	    ([] (let [P|B] Heads:
		     (clause [`{throw ,P _}] [] B Env)))
	    ##( ... : ... )
	    (_ (let {Gs (block B)} (split-tail Blocks):
		    (case Heads
		      ##( <class> <pattern> : ...)
		      ([X P]
		       (case X
			 ((atom _) ok)
			 ((var _) ok)
			 (_ (error "The class of a catch clause should be an atom or a var.")))
		       (clause [`{,X ,P _}] Gs B Env))
		      ##(<pattern> : ...)
		      ([P] (clause [`{throw ,P _}] Gs B Env))))))
	    ))


# # If E is try B catch Tc_1 ; ... ; Tc_k end, where B is a body and each Tc_i is a catch clause then Rep(E) = {'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}. 
# # If E is try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end, where B is a body, each Cc_i is a case clause and each Tc_j is a catch clause then Rep(E) = {'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}. 
# # If E is try B after A end, where B and A are bodies then Rep(E) = {'try',LINE,Rep(B),[],[],Rep(A)}. 
# # If E is try B of Cc_1 ; ... ; Cc_k after A end, where B and A are a bodies and each Cc_i is a case clause then Rep(E) = {'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}. 
# # If E is try B catch Tc_1 ; ... ; Tc_k after A end, where B and A are bodies and each Tc_i is a catch clause then Rep(E) = {'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}. 
# # If E is try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end, where B and A are a bodies, each Cc_i is a case clause and each Tc_j is a catch clause then Rep(E) = {'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}.

#\try
(defspecial try (:etc B
                 :tag of (Cs [])
		 :tag catch (Ts [])
		 :tag after (A [])
		  ) Env:
  (let L (lineno):
       {try L (transform_each B Env)
	    (lsc `(,P ;GBody) Cs: (guarded-clause [P] GBody Env))
	    (lsc T Ts: (catch-clause T Env))
	    (transform_each A Env)
	    }))


# If E is receive Cc_1 ; ... ; Cc_k end, where each Cc_i is a case clause then Rep(E) = {'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)]}. 
# If E is receive Cc_1 ; ... ; Cc_k after E_0 -> B_t end, where each Cc_i is a case clause, E_0 is an expression and B_t is a body, then Rep(E) = {'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}.

#\receive
(defspecial receive (:etc Cs :tag after (After [])) Env:
    (let L (lineno)
	 Cs (lsc `(,P ;GBody) Cs:
		 (guarded-clause [P] GBody Env))
	 :
	 (case After
	   ([] {receive L Cs})
	   ([Time|Es]
	    {receive L Cs
		     (transform Time Env)
		     (transform_each Es Env)}))))


# (defspecial try (:etc Es :tag of ))

# If E is a list comprehension [E_0 || W_1, ..., W_k], where each W_i is a generator or a filter, then Rep(E) = {lc,LINE,Rep(E_0),[Rep(W_1), ..., Rep(W_k)]}. For Rep(W), see below.

# When W is a generator or a filter (in the body of a list or binary comprehension), then: 
# If W is a generator P <- E, where P is a pattern and E is an expression, then Rep(W) = {generate,LINE,Rep(P),Rep(E)}. 
# If W is a generator P <= E, where P is a pattern and E is an expression, then Rep(W) = {b_generate,LINE,Rep(P),Rep(E)}. 
# If W is a filter E, which is an expression, then Rep(W) = Rep(E).

(def lsc-bindings (Env Qs Acc):eval:
  (case Qs
    ([] {Env (reverse Acc)})
    (['if Filter|Qs] (lsc-bindings Env Qs [(transform Filter Env)|Acc]))
    ([Pattern Generator|Qs]
     (let Env2 (verl\bindmac Pattern Env):
	  (lsc-bindings Env2 Qs [{generate (ast-line Pattern)
					   (verl\gen_pat Pattern Env2)
					   (transform Generator Env)}
				 |Acc])
	  ))))

#\lsc
(defspecial lsc (:etc Qualifiers :etc Body) Env:
  (let* Line (lineno)
	{Env RWs} (lsc-bindings Env Qualifiers [])
	:
	{lc Line
	    (transform `(begin ;Body) Env)
	    RWs}
	))



# If E is a binary constructor <<V_1:Size_1/TSL_1, ..., V_k:Size_k/TSL_k>>, then Rep(E) = {bin,LINE,[{bin_element,LINE,Rep(V_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(V_k),Rep(Size_k),Rep(TSL_k)}]}. For Rep(TSL), see below. An omitted Size is represented by default. An omitted TSL (type specifier list) is represented by default.

# A type specifier list TSL for a binary element is a sequence of type specifiers TS_1 - ... - TS_k. Rep(TSL) = [Rep(TS_1), ..., Rep(TS_k)]. 

# When TS is a type specifier for a binary element, then: 
# If TS is an atom A, Rep(TS) = A. 
# If TS is a couple A:Value where A is an atom and Value is an integer, Rep(TS) = {A, Value}.


(def bin-element (Seg Env):eval:
   (case Seg
     ((paren Seg)
      (let* {Heads TypeSpecs} (upto-block Seg) 
	    {Value Size} (case Heads
			   ([Value Size]
			    {(bin-value Value Env)
			     (bin-size Size Env)})
			   ([Value]
			    {(bin-value Value Env)
			     default}))
	    TypeSpecs (case TypeSpecs
			([] default)
			([(block Ts)]
			 (lsc T Ts:
			      (case T
				((atom T) T)
				(`(unit ,(integer Unit))
				 {unit Unit})
				))))
	    :
	    [{bin_element Value Size TypeSpecs}]
	    ))
     (_ [{bin_element (bin-value Seg Env) default default}])
     ))

(def bin-value (V Env):eval:
   (transform (do (case V
		    ((var _) true)
		    ((integer _) true)
		    ((float _) true)
		    ((string _) true)
		    (_ (error "Invalid bin value (want var,integer,float,string).")))
		  V)
	      Env))

(def bin-size (V Env):eval:
   (transform (do (case V
		    ((integer _) true)
		    (_ (error "Invalid bin size (want integer).")))
		  V)
	      Env))

(defspecial bin (:etc Segs) Env:
   (let L (lineno):
	{bin L (lsc Seg Segs: (bin-element Seg Env))}))



# If E is a binary comprehension <<E_0 || W_1, ..., W_k>>, where each W_i is a generator or a filter, then Rep(E) = {bc,LINE,Rep(E_0),[Rep(W_1), ..., Rep(W_k)]}. For Rep(W), see below.

# If W is a generator P <= E, where P is a pattern and E is an expression, then Rep(W) = {b_generate,LINE,Rep(P),Rep(E)}. 

# If W is a filter E, which is an expression, then Rep(W) = Rep(E).


# If E is fun Fc_1 ; ... ; Fc_k end where each Fc_i is a function clause then Rep(E) = {'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}.
# (fn (A B) ...)
# (fn 3 ...) == (fn (V1 V2 V3) ...)

# If E is fun Name / Arity, then Rep(E) = {'fun',LINE,{function,Name,Arity}}. 
# If E is fun Module:Name/Arity, then Rep(E) = {'fun',LINE,{function,Module,Name,Arity}}.
# (fn foo 3)


(def fn-value (Args Es Env):eval:
  (let L (lineno)
       Env (scompile\lexical_shadow Env vars []):
       {fun L
	    {clauses [(verl\clause Args [] Es L Env)]}}))


#\fn
(defspecial fn (:etc Sig Es) Env:
  (case Sig
    (`(;Args) (fn-value Args Es Env)) 
    ((integer N)
     (fn-value
      ## A1 ... AN
      (lsc I (lists\seq 1 N):
	   ## TODO this is quite an ugly way to do it.
	   ## should have a help function/macro to construct capturing var
	   (var (erlang\list_to_atom (cat "V" (erlang\integer_to_list I)))
		0
		## this variable intends to capture. Should use the pseudo module "true"
		## but this doesn't work at the moment b
		true 
		))
      Es Env)) 
    ((atom A)
     (let* L (lineno)
	   M (ast-mod Sig)
	   [(integer Arity)] Es
	   FromSource (== M (curmod)):
	   (if FromSource
	       (case (scompile\lookup_imports Env functions A)
		 ## function is associated with import
		 ({ok {{M A}}} {fun L {function M A Arity}})
		 ## function name is assumed to be local
		 (_ {fun L {function A Arity}}))
	       ## function name is remote
	       {fun L {function M A Arity}}
	       )))
    ))


# %%  If E is E_m:E_0(E_1, ..., E_k), then Rep(E) = {call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}. 
# (call Em\E0 ...)

# %%  If E is E_0(E_1, ..., E_k), then Rep(E) = {call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}.
# (call E0 ...)


(def local-call (A Args Env):eval:
     ## could be calling lexical fun
  {call (ast-line A) (transform A Env) (transform_each Args Env)})

(def remote-call (M A Args Env):eval:
  (let L (ast-line M):
       {call L
	     {remote L (transform M Env) (transform A Env)}
	     (transform_each Args Env)}))

(def lexical-call (Line Alias FreeVars Args Env):eval:
     {call Line Alias
	   (let Args (transform_each Args Env):
		(case FreeVars
		  (none Args)
		  (_ [FreeVars|Args])))})


##\call
(defspecial call (:all Fn Args) Env:
  #(fmt "call: ~p\n" [Fn])
  (case Fn
    (`{,M ,A} (remote-call M A Args Env)) 
    ((atom A L M)
     (case (scompile\lookup Env functions {M A} ~case
			    ({ok R} R)
			    (false false))
       ## unknown lexical
       ({lexical}
	## pretend it's a local call.
	#### a custom ast-type would be happier, but erl_syntax refuses to map over custom types.
	## letf transforms it to lexical call. 
	{call L {atom 0 {lexical L M A}} (transform_each Args Env)}
	)
       ## known lexical
       ({lexical Alias FreeVars} 
	(lexical-call L Alias FreeVars Args Env))
       ## import
       ({{M A}} (remote-call (atom M) (atom A) Args Env))
       ## unknown remote/local
       (_ (let Local (== M (curmod)):
	       (if Local (local-call (atom A) Args Env)
		   (remote-call (atom M) (atom A) Args Env)
		   )))))
    (_ (local-call Fn Args Env))))


## freevar analysis for the lambda-lifting of letf bindings is done in 2 passes:
## (1) collect for each lexical function the freevars in its body.
## (2) collect for each lexical function the freevars needed by the lexical function it calls.
##
##  the freevars needed by a lexical function is the union of (1) and (2)
##
## Having done the freevars analysis, associate the the lexical function with its
## toplevel alias and the freevars it needs. A call to a lexical function is
## augumented with the freevars the lexical function needs wrapped in a tuple
## as the first argument.
##
## This is extremely hairy.
(defspecial letf (:etc Fs :etc LetfBody) Env:
  (let* NABs (lsc `(,Name (;Args) ;Body) Fs:
		  {Name Args `(do ;Body)})
	## Env2 is the environment used to temporarily compile lexical functions' bodies.
	Env2 (scompile\lexical_shadow
	      Env functions
	      (lsc {(atom A _L M) _ _} NABs:
		   {{M A} {lexical}}))
	## freevar analysis (1)
	{FVs* Bindings}
	(lsc {(atom A L M) Args Body} NABs:
	     (let* {Env2 Args} (verl\patterns Args (scompile\lexical_shadow Env2 vars))
		   Body (transform Body Env2)
		   ## annotate the body for free variables.
		   ## include the args, so they don't show up in the set of freevars.
		   ABody (erl_syntax_lib\annotate_bindings
			  {function 0 foo (length Args)
				    [{clause 0 Args [] [Body]}]}
			  (ordsets\new))
		   FreeVars (erl_syntax\get_ann ABody
				.lists\keysearch free 1
				~>> {value {free Vs}} (ordsets\from_list Vs)) 
		   Alias {atom L (gensym)}
		   :
		   {{{M A} FreeVars}
		    {{M A} Alias Args Body}})
	     ~lists\unzip)
	## freevar analysis (2)
	Bindings
	(lsc {{M A} Alias Args Body} Bindings:
	     (let AllFVs (erl_syntax_lib\fold
			  ## for each lexical function used, the calling function would need
			  ## the freevars needed by the called function.
			  (fn (T AllFVs)
			      (case (erl_syntax\type T)
				(application
				 (case (erl_syntax\application_operator T .erl_syntax\revert)
				   ({atom _ {lexical _L M2 A2}}
				    (ordsets\union:
				     AllFVs
				     (lists\keysearch {M2 A2} 1 FVs*
						      ~>> {value {_ FVs}} FVs)))
				   (_ AllFVs)))
				(_ AllFVs)))
			  (lists\keysearch {M A} 1 FVs*
					   ~>> {value {_ FVs}} FVs)
			  Body): 
		  {{M A} {Alias
			  (case (lsc FV AllFVs: {var 0 FV})
			    ([] none)
			    (FVs {tuple 0 FVs})) 
			  Args
			  Body}}
		  ))
	## now we've done the freevar analysis, transform the bodies of the lexical
	## functions properly and do lambda lifting.
	Bindings
	(lsc {{M A} {Alias FVs Args Body}} Bindings:
	     (let* Body (erl_syntax_lib\map
			 (fn (T)
			     (case (erl_syntax\type T)
			       (application
				(case (erl_syntax\application_operator T .erl_syntax\revert)
				  ## a lexical call, do transform
				  ({atom _ {lexical L M A}}
				   (let* CallArgs (erl_syntax\application_arguments
						   T .erl_syntax\revert_forms)
					 {CallAlias CallFVs _ _} (lists\keysearch {M A} 1 Bindings
								      ~>> {value {_ R}} R)
					 CallArgs (case CallFVs
						    (none CallArgs)
						    (_ [CallFVs|CallArgs]))
					 :
					 {call L CallAlias CallArgs}))
				  ## an actual local call. Identity.
				  (_ T)))
			       ## identity for everything else
			       (_ T)))
			 Body
			 .erl_syntax\revert):
		   ## lambda lift
		   (let* {atom Line DefName} Alias
			 AllArgs (case FVs
				   (none Args)
				   (_ [FVs|Args]))
			 Arity (length AllArgs)
			 Ast {function Line DefName Arity
				       [{clause Line AllArgs [] [Body]}]}
			:
			(new-def functions DefName false
				 [{asts [{Arity Ast}]}]))
		   {{M A} {lexical Alias FVs}}))
	Env (scompile\lexical_shadow Env functions Bindings)
	:
	## TODO eval...
	## TODO fancy lambda list...
	## transform letf body
	(transform `(do ;LetfBody) Env)))


# #\defstruct
# (def sp-defstruct (`(,_ ,(atom Name) ;Fields) Env)
#   `(toplevel
#     ;(lsc F Fields:
# 	  (case F
# 	    ('(,FieldName ,InitExp))
# 	    (FieldName )
# 	    )))
#   )

# If E is if Ic_1 ; ... ; Ic_k end, where each Ic_i is an if clause then Rep(E) = {'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}.

##################################################
# .Control Forms

(def if-clauses (Tests Acc Line Env):eval:
  (case Tests
    ([Guard Exp|Tests]
     (if-clauses Tests
		 [(verl\clause [] Guard [Exp] (ast-line Guard) Env)
		  |Acc]
		 Line Env))
    ([Exp]
     (reverse [(verl\clause [] 'true [Exp] (ast-line Exp) Env)
	       |Acc]))
    ([] (reverse Acc))))

#\if
(defspecial if (:etc Body) Env:
  (let Line (lineno):
       {if Line (if-clauses Body [] Line Env)}))

#If E is begin B end, where B is a body, then Rep(E) = {block,LINE,Rep(B)}.

#\do
(defspecial do (:all Es) Env:
  (let L (lineno):
       {block L (transform_each Es Env)}))

#\begin
(defm begin (:all Es):
  `(do ;Es))


#\toplevel
## All toplevel forms do stuff by side-effecting. Ugly
(defspecial toplevel (:all [Form|Forms]) Env:
  (let* Section (transform Form Env) :
	(lists\foreach
	 (fn (Form)
	     (let Section2 (transform Form (scompile\env)):
		  (if (and (is-integer Section2) (== Section Section2))
		        ok
		      (is-integer Section2 )
		        (error "Toplevel forms must belong to the same section.")
		      (error "Toplevel forms should return an integer to indicate its section."))
		  ))
	 Forms)
	Section))


# (def guards (GuardTests Env):
#      (transform_each GuardTests Env))

# If E is E_1 Op E_2, where Op is a binary operator, then Rep(E) = {op,LINE,Op,Rep(E_1),Rep(E_2)}.

##################################################
# .Operators

# Term Comparisons
# == 	equal to 
# /= 	not equal to 
# =< 	less than or equal to 
# < 	less than 
# >= 	greater than or equal to 
# > 	greater than 
# =:= 	exactly equal to 
# =/= 	exactly not equal to


# Arithmetic Ops
# op 	Description 	Argument type 
# + 	unary + 	number 
# - 	unary - 	number 
# + 	  	number 
# - 	  	number 
# * 	  	number 
# / 	floating point division 	number 
# bnot 	unary bitwise not 	integer 
# div 	integer division 	integer 
# rem 	integer remainder of X/Y 	integer 
# band 	bitwise and 	integer 
# bor 	bitwise or 	integer 
# bxor 	arithmetic bitwise xor 	integer 
# bsl 	arithmetic bitshift left 	integer 
# bsr 	bitshift right 	integer

# Boolean Ops

# not 	unary logical not 
# and 	logical and 
# or 	logical or 
# xor 	logical xor

#If E is Op E_0, where Op is a unary operator, then Rep(E) = {op,LINE,Op,Rep(E_0)}.

#If E is E_1 Op E_2, where Op is a binary operator, then Rep(E) = {op,LINE,Op,Rep(E_1),Rep(E_2)}.

(def nest-bin-op (Op [Arg1 Arg2|Args] Env):eval:
  # (Op A B ...) => (Op (Op A B) C ...)
  # (- A B C ...) => (- (- A B) C ...)
  (foldl (fn (Arg Exp)
	     {op (ast-line Arg) Op
		 Exp
		 (transform Arg Env)})
	 {op (lineno) Op (transform Arg1 Env) (transform Arg2 Env)}
	 Args))

(def bin-op (Op [Arg1 Arg2] Env):eval:
  {op (ast-line Arg1)
      Op
      (transform Arg1 Env)
      (transform Arg2 Env)})

(def una-op (Op [Arg1] Env):eval:
  {op (ast-line Arg1)
      Op
      (transform Arg1 Env)})

(defm def-ops (:etc Specs):
  `(toplevel
    ;(lsc `(,(atom Type) ;Names) Specs:
	  (case Type
	    (binary-nested
	     `(toplevel
	       ;(lsc Op Names:
		     `(defspecial ,Op (:etc Args) Env:
			(nest-bin-op ,Op Args Env)))))
	    (binary
	     `(toplevel
	       ;(lsc Op Names:
		     `(defspecial ,Op (:etc Args) Env:
			(bin-op ,Op Args Env)))))
	    (unary
	     `(toplevel
	       ;(lsc Op Names:
		     `(defspecial ,Op (:etc Args) Env:
			(una-op ,Op Args Env)))))
	    ))))

(def-ops
  (binary-nested + - * / ++ --)
  (binary == /= =< < >= >) 
  (binary div rem bnot band bor bxor bsl bsr)
  (binary-nested and or xor orelse andalso)
  (unary not))

## ===, /== defined separately, because they are named differently.

(defspecial === (:etc Args) Env:
  (nest-bin-op %a{=:=} Args Env))

(defspecial /== (:etc Args) Env:
  (nest-bin-op %a{=/=} Args Env))



##################################################
# .Data Types
#
# should probably be at the end, otherwise makes compilation slow.

(defspecial tuple ((block Es)) Env:
  (let L (lineno):
       {tuple L (transform_each Es Env)}))

(def list-of (Heads Tail):eval:
     (foldr (fn (H T) `(cons ,H ,T))
	    Tail Heads))

(defm ls (:all Es):
      (case Es
	([(block Heads) (block [Tail])]
	 (list-of Heads Tail))
	([(block Heads)]
	 (list-of Heads '(cons)))
	([] '(cons))))

(defspecial cons (:all Es) Env:
  (let L (lineno):
       (case Es
	 ([] {nil L})
	 ([Head Tail]
	  {cons L
		(transform Head Env)
		(transform Tail Env)}))))
