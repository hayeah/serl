## make sure I can change the AST representation whenver I feel like it.

(module serl)

(import scompile
	error
	lineno
	curmod
	transform
	transform_each
	map_env0
	genvar
	gensym
	)

(import lists
	map 
	foldl
	foldr
	reverse
	member
	foreach
	)

(import erlang
	length)

## verl's meta-module doesn't support import.
### this is a special case
# (import verl clause) 
#(importm verl ...)

# (export ast-tag ast-line ast-mod ast-data
# 	upto-block
# 	atom-cat
# 	erlpp ## TODO: remove when eval-only is implemented
# 	output-forms ## TODO: remove later when verl is removed.
# 	)

(export-from
 (functions
  ast-tag ast-line ast-mod ast-data
  upto-block
  atom-cat
  erlpp		     ## TODO: remove when eval-only is implemented
  output-forms	     ## TODO: remove later when verl is removed.
  )
 (specials
  %a{__eof} %a{__bof}
  %a{__block} %a{__brace} 
  def defm defspecial
  functions-import functions-export functions-output
  #macros-import
  macros-export macros-output
  #specials-import
  specials-export specials-output
  let lsc
  fn call 
  case if
  toplevel
  + - * / ==
  not
  )
 (macros
  export-from import-from
  export import
  let*
  ))


##################################################
# .Helper


(def ast-tag (Ast):eval: (erlang\element 1 Ast))
(def ast-line (Ast):eval: (erlang\element 2 Ast))
(def ast-mod (Ast):eval: (erlang\element 3 Ast))
(def ast-data (Ast):eval: (erlang\element 4 Ast))

(def erlpp (Ast):eval:
     (fmt "~s\n" [(erl_pp\expr Ast)]))

(def upto-block (Es):eval:
  (let {UpToFirstBlock Rest} (lists\splitwith
			      (fn (E)
				  (case E
				    ((block _) false)
				    (_ true)))
			      Es):
       {UpToFirstBlock Rest}
       ))

(def atom-cat (Vs):eval:
  ## perhaps name it catom??
  (foldl
   (fn (V Acc)
       (let Str (if (erlang\is_integer V) (erlang\integer_to_list V)
		    (erlang\is_atom V) (erlang\atom_to_list V)
		    (erlang\is_list V) V):
	    [Str|Acc]))
   [] Vs
   .reverse ~string\join "-" .erlang\list_to_atom))


#\with-genvar

(defm with-genvar (:etc Vars :etc Body): 
  `(let ;(lists\foldl
	  (fn (Var Acc) [Var '(scompile\genvar)|Acc])
	  []
	  Vars):
     ;Body
     ))


# (def clause (Ps G Es Line Env):
#   (let {Env RPs} (verl\patterns Ps Env)
# 	  :
#        {clause Line (transform_each Es Env2)
# 	       ## an erlang clause takes a guard sequence
# 	       ## a guard sequence is a list of guard tests
# 	       ## (we support only one guard sequence)
# 	       (verl\guards Gs Env ~>> {_ RGs} RGs)
# 	       (transform_each Es Env ~>> {_ REs} REs)}
#        ))

# clause(Ps,G,Es,Line,Env) ->
#     %% A <guard> is a list of <guard-test>
#     {Env2,RPs}=patterns(Ps,scompile:lexical_shadow(Env,vars,[])),
#     REs=transform_each(Es,Env2), 
#     GuardSequence=
# 	case G of
# 	    [] -> [];
# 	    _ -> [[guard(G,Env2)]]
# 	end,
#     {clause,Line, RPs, GuardSequence, REs}.


##################################################
# .Pseudo Forms


(defspecial %a{__bof} () Env:
  {0 Env})

(defspecial %a{__eof} (Command) Env:
  (case Command
    (normal (verl\emit (output-forms Env) Env
		       (verl\set_opts (scompile\options))))
    (after (verl\cleanup))))

(defspecial %a{__block} (:etc [Es]) Env:
  (transform `(ls: ;Es) Env))

(defspecial %a{__brace} (:etc [Es]) Env: 
  (transform `(tuple: ;Es) Env))

(def output-forms (Env):eval:
  ## do output for each NS types
  (let* Types (lsc {Type _} (env\assoc Env [definitions] ~>>
				       {ok NSs} NSs):
		   Type):
	(foldl (fn (Type {Info Headers Bodies})
		   ## transform (<Type>-output) for each namespace
		   (transform `(,(atom (atom-cat: Type output)) ,Info) Env
			      ~>> {I H B} {I [H|Headers] [B|Bodies]}))
	       {(env\new) [] []}
	       Types
	       ~>> {Info Headers Bodies}
		(let Info (env\assoc_put Info [imports]
					 (env\assoc Env [imports]
						    ~>> {ok Imports} Imports)):
		  (lists\flatten [{attribute 0 module (curmod)}
				  {attribute 0 serl true}
				  {attribute 0 serl_info Info}
				  Headers Bodies])
		  ))))


##################################################
# 1. Environment
#
# Just support functions & macros/specials for the moment.

## (export "sp-.*")
## (export "mac-.*")

# (import-from mod (macros ...) (functions ...))


(def export-defs (Env Type Names):eval:
  (env\assoc_append Env [exports Type] Names))

(def get-exports (Env Type):eval:
  (env\assoc Env [exports Type] ~case
	     ({ok Names} Names)
	     (_ [])))

# (def get-imports (Env Type):eval:
#      (let Names (env\assoc Env [imports] ~>> {ok Imports}
# 			   (lsc {Mod _} Imports
# 				Name (env\assoc [imports Mod Type] ~>> {ok }
# 						)
# 				: Mod)):
# 	  Namess (lsc Mod Mods
# 		      Val (env\imports_of Mod Type all ~>> {Type Vals}):
# 		      )
# 	  ))


(def new-def (Env NSType Name Def):eval:
  (let Defined (env\assoc Env [definitions NSType Name]):
       (if Defined (error "%s already defined in %s" [Name NSType])
	   (env\assoc_put Env [definitions NSType Name] Def)
	   )))

(def def-info (Env NSType Name Key):eval:
  # caller of this function should check its result
  (case (env\assoc Env [definitions NSType Name])
    ({ok Def} (proplists\lookup Key (erlang\element 2 Def) ~case
				(none false)
				({_ R} {ok R})))
    (_ false)))

# (def get-def (Env NSType Name):eval:
#   # get the definition of a name
#   (env\assoc Env [definitions NSType Name] ~case
# 	     ({ok Def} Def)
# 	     (_ false)))

(def get-defs (Env NSType):eval:
  # get all the definitions related to a namespace
  (env\assoc Env [definitions NSType] ~case
	     ({ok Defs} Defs)
	     (false [])))


#\import-from
(defm import-from (:etc Mod Specs):
  `(toplevel
    ;(lsc `(,(atom Type) ;Names) Specs:
	  `(,(atom (atom-cat: Type import)) ,Mod ;Names)
	  )))


# (export-from (functions a b c) (macros c d e)) ## =>
# (toplevel
#  (functions-export a b c)
#  (macros-export c d e))

#\export-from
(defm export-from (:etc Specs):
  `(toplevel
    ;(lsc `(,(atom Type) ;Names) Specs:
	  `(,(atom (atom-cat: Type export)) ;Names)
	  )))

#\import
(defm import (:etc Mod Names):
  `(functions-import ,Mod ;Names))

(defspecial functions-import (:etc Mod Names) Env:
  (let (atom Mod) Mod
       Names (lsc (atom A) Names: A):
       (foreach (fn (Name)
		    (case (scompile\lookup Env functions {(curmod) Name})
		      ({ok {{M A}}} (error "Function import conflict: ~p:~p with ~p:~p"
					   [Mod Name M A]))
		      (_ ok)))
		Names)
       ##TODO allow importing functions from not yet loaded modules
       {2 (env\import Env Mod functions Names)}
       ))

#\export
(defm export (:etc Mod Names):
  `(functions-export ,Mod ;Names))

#If F is an attribute -export([Fun_1/A_1, ..., Fun_k/A_k]), then Rep(F) = {attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}.

(defspecial functions-export (:etc Names) Env:
  (fmt "fun-export: ~p\n" [Names])
  {2 (export-defs Env functions Names)})

(defspecial functions-output (Info) Env:
  (output-fun Info Env functions))



(defspecial macros-export (:etc Names) Env:
  {2 (export-defs Env macros Names)})

(defspecial macros-output (Info) Env:
  (output-meta-fun Info Env macros))



(defspecial specials-export (:etc Names) Env:
  {2 (export-defs Env specials Names)})

(defspecial specials-output (Info) Env:
  (output-meta-fun Info Env specials))



(def output-fun (Info Env Type):eval:
  ## used so far by functions
     (fmt "output: ~p\n" [Type])
  (let* FNames (lsc {Name _} (get-defs Env Type):
		    Name)
	Exports (lsc Export (get-exports Env Type): 
		     {(ast-line Export)
		      (ast-data Export)
		      })
	Info (env\assoc_put
	      Info [exports Type]
	      (let M (curmod):
		   (lsc {Line Name} Exports:
			{Name {{M Name}
			       [{doc
				 (def-info Env Type Name doc ~case
					   ({ok Doc} Doc)
					   (_ (error "~p: Exporting ~p undefined: ~p"
						     [Line Type Name])))
				 }]}})))
	:
	##(fmt "Info: ~p\n" [Info])
	{Info
	 ##export attributes
	 (lsc {Line Name} Exports
	      Arity (def-info Env Type Name arities ~>>
			      {ok Arities} Arities):
	      {attribute Line export
			 [{Name Arity}]})
	 ##definitions
	 (lsc Name FNames:
	      (def-info Env Type Name ast ~case
			({ok Ast} Ast)))
	 }))

(def output-meta-fun (Info Env Type):eval:
  ## shared by exports,specials
  ## only the exported defs need actually be output
     (fmt "output-meta: ~p\n" [Type])
  (let* Exports (lsc Export (get-exports Env Type):
		     {(ast-line Export) (ast-data Export)})
	{Headers Bodies}
	(lsc {Line Name} Exports:
	     (let* MacName (def-info Env Type Name name ~case
				     ({ok Name} Name)
				     (_ (error "~p: Exporting ~p undefined: ~p"
					       [Line Type Name])))
		   Attributes (lsc Arity (def-info Env Type Name arities ~>>
						   {ok Arities} Arities):
				   {attribute Line export [{MacName Arity}]})
		   Ast (def-info Env Type Name ast ~case
				 ({ok Ast} Ast)):
		   {Attributes Ast})
	     .lists\unzip)
	Info
	(env\assoc_put Info [exports Type]
		       (lsc {_L Name} Exports:
			    {Name {## Fun
				   {(curmod) (def-info Env Type Name name ~>>
						       {ok MacName} MacName)}
				   ## Info
				   [{doc (def-info Env Type Name doc ~>>
						   {ok Doc} Doc)}]}}))
	:
	##(fmt "Info: ~p\n" [Info])
	{Info 
	 ## export attributes
	 (lists\flatten Headers)
	 ## definitions
	 Bodies})) 




##################################################
# .Definitions


(def macro-parse-args (Args Body VAll):eval:
  # V_n are the continuaton variables that store partial parsing results.
  # parse the required args or a leading :etc block (special case).
  # auxiliary args must follow the leading args.
     #(fmt "MPA:\nBody: ~p\n" [Body])
  (case Args
    ([] `(let (paren [_Car]) ,VAll : ;Body))
    ([(block ['etc|EArgs])|Blocks]
     (let {Heads Tail} (reverse EArgs ~>> [Tail|RHeads]
				{(reverse RHeads) Tail})
	  VK (genvar) VK2 (genvar)
	  :
	  `(let* (paren [_Car ;Heads | ,VK]) ,VAll
		 {,Tail ,VK2} (upto-block ,VK)
		 : ,(macro-arg-blocks Blocks Body VAll VK2))))
    (_ (let* {Heads Blocks} (upto-block Args)
	     VK (genvar)
	     :
	     `(let (paren [_Car ;Heads | ,VK]) ,VAll
		   : ,(macro-arg-blocks Blocks Body VAll VK))
	     ))))

(def macro-arg-blocks (Blocks Body VAll VK):eval:
    (let* {Blocks AuxBlocks} (lists\partition
				 (fn ((block [(atom Type) | _]))
				     ## raise error if type not recognized
				     (case Type
				       (etc true)
				       (tag true)
				       (all false)
				       (_ (error "Unrecognized macro argument block: ~p"
						 [Type]))))
				 Blocks) 
	  AuxBindings (macro-aux-blocks AuxBlocks VAll)
	  :
	  (case Blocks
	    ([] `(let ;AuxBindings : ,VK ;Body))
	    (_ `(let ;AuxBindings
		  : ,(macro-arg-blocks-2 Blocks Body VK)))
	    #~>> R (fmt "MAB -> ~p\n" [R]) R
	     )))

(def macro-arg-blocks-2 (Blocks Body VK):eval:
  # parse the non-auxiliary block args
  # key & etc
  (case Blocks
    ([] `(case ,VK
	   ([] ;Body)))
    ([(block [(atom Type)|Args])|Blocks]
     (case Type
       (etc (let VK2 (genvar)
		 EtcBinding (case Args
			      ([Tail] Tail)
			      ## more than two args in :etc
			      ([_ _|_] (reverse Args ~>> [Tail|RHeads]
					  `[;(reverse RHeads)|,Tail]))) 
		 :
		 `(let [(block ,EtcBinding)|,VK2] ,VK
		       : ,(macro-arg-blocks-2 Blocks Body VK2))))
       (tag (let [Tag TagArg] Args
		 VK2 (genvar) 
		 :
		 `(let {,TagArg ,VK2} (case ,VK
					([(block [(atom ,Tag)|TagVal])|Blocks]
					 {TagVal Blocks})
					(Args {false Args})):
		       ,(macro-arg-blocks-2 Blocks Body VK2))
		 ))
       ))))

(def macro-aux-blocks (Blocks VAll):eval:
  # auxiliary arguments that don't consume arguments.
  (foldl (fn ((block [Type|Spec]) Bindings)
	     (case Type
	       ('all [(>> Spec [AllArg] AllArg) VAll | Bindings])))
	 []
	 Blocks))


#\def
(defspecial def ((atom Name) `(;Args)
		 :tag doc Doc
		 :tag eval Eval
		 :etc Body) Env:
  (fmt "def: ~p\n" [Name])
  (let* Line (lineno)
	Arity (length Args)
	EvalFlag (case Eval (false false) (_ true))
	Doc (case Doc (false "") (_ Doc))
	DefAst {function Line Name Arity
			 [(verl\clause Args [] Body Line Env)]}
	EvalVarName (gensym)
	EvalVar (var EvalVarName)
	## Note that the it expects compiler to pass in the args in a list.
	EvalAst (if EvalFlag (transform
			      `(case (eval-binding ,EvalVar)
				 ([;Args] ;Body))
			      Env)
		    false)
	## TODO support multiple arities 
	EvalFn (if EvalFlag (fn (Args Env)
				# the environment at the time of call is passed in.
				(scompile\eval_erl EvalAst [{EvalVarName Args}] Env ~>>
						   {Result _} Result))
		   {(curmod) Name})
	:
	#(erlpp EvalAst)
	{10 (new-def Env functions Name
		     {EvalFn
		      [{ast DefAst}
		       {doc Doc}
		       {eval EvalFlag}
		       {arities [Arity]}]})}
	))


#\defm
(defspecial defm ((atom Name) `(;Args)
		       :tag doc Doc
			:etc Body) Env:
  (fmt "defm: ~p\n" [Name])
  (let* Doc (case Doc (false "") (_ Doc))
	Line (lineno)
	#the variable for the whole macro expression
	VAllName (gensym)
	VAll (var VAllName)
	#the actual name to define the macro function
	MacName (atom-cat: "$mac" Name) 
	MacBody (macro-parse-args Args Body VAll) 
	## the macro function interprets the erl-ast of the macro definition
	## the macro function closes over the current  meta-environment.
	## the macro is not visible to its own definition.
	## ## but the macro /can/ be used recursively.
	## functions defined after the macro are not visible.
	## ## I think this is sensible... 
	EvalAst (transform 
		 `(let ,VAll (eval-binding ,VAll) :
		       ##(io\format "VAll ~p\n" [,VAll])
		       ,MacBody)
		 Env)
	EvalFn
	(begin
	 ##(io\format "EvalAst: \n~s\n" [(erl_pp\expr EvalAst)])
	 (fn (Ast) 
	     (scompile\eval_erl EvalAst [{VAllName Ast}] Env ~>>
				{Result _} Result)
	     ))
	DefAst {function Line MacName 1
			 [(verl\clause [VAll] [] [`(begin ,MacBody)] Line Env)]}
	:
	#(fmt "defm ok\n")
	{10 (new-def Env macros Name
		     {EvalFn
		      [{ast DefAst}
		       {arities [1]}
		       {name MacName}
		       {args Args} 
		       {doc Doc}]})}))


#\defspecial
(defspecial defspecial ((atom Name) `(;Args) VEnv
		       :tag doc Doc
			:etc Body) Env :
  (fmt "defspecial: ~p\n" [Name])
  (let* Doc (case Doc (false "") (_ Doc))
	Line (lineno)
	#the variable for the whole macro expression
	VAllName (gensym)
	VAll (var VAllName)
	#the variable for the environment during expansion
	#VEnv
	VEnvName (let (var Name) VEnv: Name) 
	#the actual name to define the macro function
	MacName (atom-cat: "$special" Name) 
	MacBody (macro-parse-args Args Body VAll)
	EvalAst (transform 
		 `(let ,VAll (eval-binding ,VAll)
		       ,VEnv (eval-binding ,VEnv)
		      :,MacBody)
		 Env)
	EvalFn
	(begin
	 ##(io\format "EvalAst: \n~s\n" [(erl_pp\expr EvalAst)])
	 (fn (Ast Env)
	     #(fmt "expand special ~p\nAST:~p\n" [Name Ast])
	     (let {Result _} (scompile\eval_erl EvalAst [{VAllName Ast}
							 {VEnvName Env}]
						Env):
		  Result)))
	DefAst {function Line MacName 2
			 [(verl\clause [VAll VEnv] [] [`(begin ,MacBody)] Line Env)]}
	: 
	##(erlpp EvalAst)
	## the macro definition needs to be in meta and normal env
	#(fmt "defspecial ok\n")
	{10 (new-def Env specials Name
		     {EvalFn
		      [{ast DefAst}
		       {arities [2]}
		       {name MacName}
		       {args Args} 
		       {doc Doc}]})}))


##################################################
# 3. Binding Forms


(def let-bindings (Bindings Patterns Assignments):eval:
     (case Bindings
       ([] {(reverse Patterns) (reverse Assignments)})
       ([Pattern Value|Bindings]
	(let-bindings Bindings [Pattern|Patterns] [{Pattern Value}|Assignments]))))

#\let
(defm let* (:etc Bindings :etc Body):
  (case Bindings
    ([] `(begin ;Body))
    ([Pattern Value|Bindings] `(let ,Pattern ,Value: (let* ;Bindings: ;Body)))))

(defspecial let (:etc Bindings :etc Body) Env:
  (let* Line (lineno) 
	{Patterns Assignments} (let-bindings Bindings [] []) 
	Env2 (verl\binds Patterns (scompile\lexical_shadow Env vars []))
	Assignments
	(lsc {P V} Assignments:
	     {match (ast-line P)
		    (verl\gen_pat P Env2) # pattern generated with new bindings
		    (transform V Env)} # value evaluated with old environment
	     ) 
	: 
	{block Line (cat Assignments (transform_each Body Env2))}))


(defm >> (:etc Val Pattern Body):
  `(let ,Pattern ,Val: ;Body))


# If E is case E_0 of Cc_1 ; ... ; Cc_k end, where E_0 is an expression and each Cc_i is a case clause then Rep(E) = {'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}.

#\case
(defspecial case (:etc E Cs) Env:
  (let Line (lineno):
       {case Line
	 (transform E Env)
	 (lsc `(,P ;Es) Cs:
	      (verl\clause [P] [] Es (ast-line P) Env))}
       )) 

# If E is a list comprehension [E_0 || W_1, ..., W_k], where each W_i is a generator or a filter, then Rep(E) = {lc,LINE,Rep(E_0),[Rep(W_1), ..., Rep(W_k)]}. For Rep(W), see below.

# When W is a generator or a filter (in the body of a list or binary comprehension), then: 
# If W is a generator P <- E, where P is a pattern and E is an expression, then Rep(W) = {generate,LINE,Rep(P),Rep(E)}. 
# If W is a generator P <= E, where P is a pattern and E is an expression, then Rep(W) = {b_generate,LINE,Rep(P),Rep(E)}. 
# If W is a filter E, which is an expression, then Rep(W) = Rep(E).

(def lsc-bindings (Env Qs Acc):eval:
  (case Qs
    ([] {Env (reverse Acc)})
    (['if Filter|Qs] (lsc-bindings Env Qs [(transform Filter Env)|Acc]))
    ([Pattern Generator|Qs]
     (let Env2 (verl\bindmac Pattern Env):
	  (lsc-bindings Env2 Qs [{generate (ast-line Pattern)
					   (verl\gen_pat Pattern Env2)
					   (transform Generator Env)}
				 |Acc])
	  ))))

#\lsc
(defspecial lsc (:etc Qualifiers :etc Body) Env:
  (let* Line (lineno)
	{Env RWs} (lsc-bindings Env Qualifiers [])
	:
	{lc Line
	    (transform `(begin ;Body) Env)
	    RWs}
	))



# If E is fun Fc_1 ; ... ; Fc_k end where each Fc_i is a function clause then Rep(E) = {'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}.
# (fn (A B) ...)
# (fn 3 ...) == (fn (V1 V2 V3) ...)

# If E is fun Name / Arity, then Rep(E) = {'fun',LINE,{function,Name,Arity}}. 
# If E is fun Module:Name/Arity, then Rep(E) = {'fun',LINE,{function,Module,Name,Arity}}.
# (fn foo 3)


(def fn-value (Args Es Env):eval:
  (let L (lineno)
       Env (scompile\lexical_shadow Env vars []):
       {fun L
	    {clauses [(verl\clause Args [] Es L Env)]}}))


#\fn
(defspecial fn (:etc Sig Es) Env:
  (case Sig
    (`(;Args) (fn-value Args Es Env)) 
    ((integer N)
     (fn-value
      ## A1 ... AN
      (lsc I (lists\seq 1 N):
	   ## TODO this is quite an ugly way to do it.
	   ## should have a help function/macro to construct capturing var
	   (var (erlang\list_to_atom (cat "V" (erlang\integer_to_list I)))
		0
		## this variable intends to capture. Should use the pseudo module "true"
		## but this doesn't work at the moment b
		true 
		))
      Es Env)) 
    ((atom A)
     (let* L (lineno)
	   M (ast-mod Sig)
	   [(integer Arity)] Es
	   FromSource (== M (curmod)):
	   (if FromSource
	       (case (scompile\lookup_imports Env functions A)
		 ## function is associated with import
		 ({ok {{M A}}} {fun L {function M A Arity}})
		 ## function name is assumed to be local
		 (_ {fun L {function A Arity}}))
	       ## function name is remote
	       {fun L {function M A Arity}}
	       )))
    ))


# %%  If E is E_m:E_0(E_1, ..., E_k), then Rep(E) = {call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}. 
# (call Em\E0 ...)

# %%  If E is E_0(E_1, ..., E_k), then Rep(E) = {call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}.
# (call E0 ...)

(def local-call (A Args Env):eval:
  {call (ast-line A) (transform A Env) (transform_each Args Env)})

(def remote-call (M A Args Env):eval:
  (let L (ast-line M):
       {call L
	     {remote L (transform M Env) (transform A Env)}
	     (transform_each Args Env)}))

#\call 
(defspecial call (:etc Fn Args) Env:
  (case Fn
    (`{,M ,A} (remote-call M A Args Env)) 
    ((atom A)
     (let* M (ast-mod Fn)
	   ## check to see if the atom is from the source or from macro.
	   FromSource (== M (curmod)): 
	   (if FromSource
	       (case (scompile\lookup_imports Env functions A)
		 ## atom is associated with import
		 ({ok {{M A}}} (remote-call (atom M) (atom A) Args Env))
		 ## atom is assumed to be local call
		 (R (io\format "Result: ~p\n Env: ~p\n" [R Env])
		    (local-call Fn Args Env)))
	       ## atom is not from the source, so interpret as remote
	       (remote-call (atom M) Fn Args Env))
	   ))
    (_ (local-call Fn Args Args))))

##################################################
# .Misc

# #\defstruct
# (def sp-defstruct (`(,_ ,(atom Name) ;Fields) Env)
#   `(toplevel
#     ;(lsc F Fields:
# 	  (case F
# 	    ('(,FieldName ,InitExp))
# 	    (FieldName )
# 	    )))
#   )

# If E is if Ic_1 ; ... ; Ic_k end, where each Ic_i is an if clause then Rep(E) = {'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}.

##################################################
# .Control Forms

(def if-clauses (Tests Acc Line Env):eval:
  (case Tests
    ([Guard Exp|Tests]
     (if-clauses Tests
		 [(verl\clause [] Guard [Exp] (ast-line Guard) Env)
		  |Acc]
		 Line Env))
    ([Exp]
     (reverse [(verl\clause [] 'true [Exp] (ast-line Exp) Env)
	       |Acc]))
    ([] (reverse Acc))))

#\if
(defspecial if (:etc Body) Env:
  (let Line (lineno):
       {if Line (if-clauses Body [] Line Env)}))

#\toplevel
(defspecial toplevel (:etc [Form|Forms]) Env:
  (let* {Section Env} (transform Form Env)
	Env
	(lists\foldl
	 (fn (Form Env)
	     (let {Section2 Env} (transform Form Env):
		  (if (== Section Section2) Env
		      (error "Toplevel forms must belong to the same section."))
		  ))
	 Env Forms)
	:
	{Section Env}))

# (def guards (GuardTests Env):
#      (transform_each GuardTests Env))

# If E is E_1 Op E_2, where Op is a binary operator, then Rep(E) = {op,LINE,Op,Rep(E_1),Rep(E_2)}.

##################################################
# .Operators

# Term Comparisons
# == 	equal to 
# /= 	not equal to 
# =< 	less than or equal to 
# < 	less than 
# >= 	greater than or equal to 
# > 	greater than 
# =:= 	exactly equal to 
# =/= 	exactly not equal to


# Arithmetic Ops
# op 	Description 	Argument type 
# + 	unary + 	number 
# - 	unary - 	number 
# + 	  	number 
# - 	  	number 
# * 	  	number 
# / 	floating point division 	number 
# bnot 	unary bitwise not 	integer 
# div 	integer division 	integer 
# rem 	integer remainder of X/Y 	integer 
# band 	bitwise and 	integer 
# bor 	bitwise or 	integer 
# bxor 	arithmetic bitwise xor 	integer 
# bsl 	arithmetic bitshift left 	integer 
# bsr 	bitshift right 	integer

# Boolean Ops

# not 	unary logical not 
# and 	logical and 
# or 	logical or 
# xor 	logical xor

# (def-ops
#     (binary-nested + - * /)
#     (binary == /= =< < >= >) 
#   (binary div rem bnot band bor bxor bsl bsr)
#   #(binary === /==) # defined separately
#   (unary not and or xor))

# (def-ops
#     :binary-nested
#     + - * /
#     :binary
#      == /= =< < >= >
#      div rem
#      bnot band bor bxor bsl bsr
#      # === /== # defined separately
#      :unary
#       not and or xor
#   )

#If E is Op E_0, where Op is a unary operator, then Rep(E) = {op,LINE,Op,Rep(E_0)}.

#If E is E_1 Op E_2, where Op is a binary operator, then Rep(E) = {op,LINE,Op,Rep(E_1),Rep(E_2)}.

(def nest-bin-op (Op [Arg1 Arg2|Args] Env):eval:
  # (Op A B ...) => (Op (Op A B) C ...)
  # (- A B C ...) => (- (- A B) C ...)
  (foldl (fn (Arg Exp)
	     {op (ast-line Arg) Op
		 Exp
		 (transform Arg Env)})
	 {op (lineno) Op (transform Arg1 Env) (transform Arg2 Env)}
	 Args))

(def bin-op (Op [Arg1 Arg2] Env):eval:
  {op (ast-line Arg1)
      Op
      (transform Arg1 Env)
      (transform Arg2 Env)})

(def una-op (Op [Arg1] Env):eval:
  {op (ast-line Arg1)
      Op
      (transform Arg1 Env)})


(defspecial + (:etc Args) Env:
  (nest-bin-op + Args Env))

(defspecial - (:etc Args) Env:
  (nest-bin-op - Args Env))

(defspecial / (:etc Args) Env:
  (nest-bin-op / Args Env))

(defspecial * (:etc Args) Env:
  (nest-bin-op * Args Env))

(defspecial == (:etc Args) Env:
  (bin-op == Args Env))

(defspecial not (:etc Args) Env:
  (una-op not Args Env))


