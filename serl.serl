## make sure I can change the AST representation whenver I feel like it.

(module serl)

(import scompile
	error
	lineno
	curmod
	transform
	transform_each
	map_env0
	genvar
	gensym
	)

(import lists
	map
	foldl
	foldr
	reverse
	member)

## verl's meta-module doesn't support import.
### this is a special case
## (import verl clause)

#(importm verl ...)

# (def get-meta-env:
#   ((Env): env\assoc(Env [compile_env])))
# (def put-meta-env:
#   ((Env MEnv): env\assoc_put(Env [compile_env] MEnv)))

(export sp-block
	sp-brace
	sp-fn
	sp-let
	sp-lsc
	sp-case
	sp-if
	sp-defm
	sp-defspecial

	sp-import-from

	)

(export mac->>
	mac-with-genvar
	mac-let*)

(export upto-block)

# (export
#   sp-+
# #  sp--
# #  sp-*
# #  sp-/
#  sp-==
# #  sp-<
#  sp->
#  )


## (export "sp-.*")
## (export "mac-.*")

## should import to both the meta and normal environments
# (def sp-import (`(,_ ;Form) Env):
#   )

# (import-from mod (macros ...) (functions ...)) 
(def sp-import-from (`(,_ ,Mod ;Specs) Env):
  (let (atom Mod) Mod:
       {2 (env-import Env Mod Specs)}
       ))

(def env-import (Env Mod Specs):
  (case Specs
    ([] Env)
    ([`(,Type ;Names)|Specs]
     (let Names (lsc (atom A) Names: A)
	  (atom Type) Type:
	  (lists\foreach
	   (fn (Name)
	       (case (scompile\lookup Env Type {(curmod) Name})
		 ({ok _} (error "Import conflict: ~p:~p" [Mod Name]))
		 (_ ok)))
	   Names)
	  #TODO allow importing unknown functions 
#     Env2=try env:import(Env,Mod,functions,Imports)
# 	 catch no_imports ->
# 		 env:assoc_put(
# 		   Env,
# 		   [imports,Mod,functions],
# 		   [{F,{Mod,F}} || F <- Imports]) 
# 	 end,
	  (env-import (env\import Env Mod Type Names) Mod Specs)
	  ))))

# (defm importm (Mod :pos Names)
#   `(import-from ,Mod (macros ;Names)))

# (defm import (Mod :pos Names)
#   `(import-from ,Mod (functions ;Names)))


(def mac-let* (`(,_ ;Form)):
  (let {Bindings [(block Body)]} (upto-block Form):
       (case Bindings
	 ([] `(begin ;Body))
	 ([Pattern Value|Bindings] `(let ,Pattern ,Value: (let* ;Bindings: ;Body))))))

(def sp-let (`(let ;Es) Env):
  (let* Line (lineno)
	{Bindings [(block Body)]} (upto-block Es)
	{Patterns Assignments} (let-bindings Bindings [] [])
	Env2 (verl\binds Patterns (scompile\lexical_shadow Env vars []))
	Assignments (map
		     (fn ({P V}):
			 {match (element 2 P)
				(verl\gen_pat P Env2) # pattern generated with new bindings
				(transform V Env)} # value evaluated with old environment
			 )
		     
		     Assignments):
	{block Line (cat Assignments (transform_each Body Env2))}))

(def let-bindings (Bindings Patterns Assignments):
     (case Bindings
       ([]: {(reverse Patterns) (reverse Assignments)})
       ([Pattern Value|Bindings]:
	(let-bindings Bindings [Pattern|Patterns] [{Pattern Value}|Assignments]))))

(def mac-with-genvar (`(,_ ;Form)):
  (let {Vars [BodyBlock]} (upto-block Form):
       `(let ;(lists\foldl
	       (fn (Var Acc) [Var '(scompile\genvar)|Acc])
	       []
	       Vars)
	  ,BodyBlock
	  )))

# If E is a list comprehension [E_0 || W_1, ..., W_k], where each W_i is a generator or a filter, then Rep(E) = {lc,LINE,Rep(E_0),[Rep(W_1), ..., Rep(W_k)]}. For Rep(W), see below.

# When W is a generator or a filter (in the body of a list or binary comprehension), then: 
# If W is a generator P <- E, where P is a pattern and E is an expression, then Rep(W) = {generate,LINE,Rep(P),Rep(E)}. 
# If W is a generator P <= E, where P is a pattern and E is an expression, then Rep(W) = {b_generate,LINE,Rep(P),Rep(E)}. 
# If W is a filter E, which is an expression, then Rep(W) = Rep(E).

(def sp-lsc (`(,_ ;Form) Env):
  (let* Line (lineno)
	{Qualifiers [(block Body)]} (upto-block Form)
	{Env RWs} (lsc-bindings Env Qualifiers [])
	:
	{lc Line
	    (transform `(begin ;Body) Env)
	    RWs}
	))

(def lsc-bindings (Env Qs Acc):
  (case Qs
    ([] {Env (reverse Acc)})
    (['if Filter|Qs] (lsc-bindings Env Qs [(transform Filter Env)|Acc]))
    ([Pattern Generator|Qs]
     (let Env2 (verl\bindmac Pattern Env):
	  (lsc-bindings Env2 Qs [{generate (ast-line Pattern)
					   (verl\gen_pat Pattern Env2)
					   (transform Generator Env)}
				 |Acc])
	  ))))


(def new-def (Env NSType Name Def):
  (let Defined (env\assoc Env [definitions NSType Name]):
       (if Defined (error "%s already defined in %s" [Name NSType])
	   (env\assoc_put Env [definitions NSType Name] Def)
	   )))

(def sp-defm (`(,_Car ,Name (;Args) :;Body) Env):
  (let* Name (let (atom Name) Name: Name)
	MEnv (let {ok MEnv} (verl\get_meta_env Env): MEnv)
	Line (lineno)
	#the variable for the whole macro expression
	VAllName (gensym)
	VAll (var VAllName)
	#the actual name to define the macro function
	MacName (erlang\list_to_atom
		 (cat "$mac$" (erlang\atom_to_list Name))) 
	MacBody (macro-arg-1 Args Body VAll)
	## the macro function interprets the erl-ast of the macro definition
	## the macro function closes over the current  meta-environment.
	## the macro is not visible to its own definition.
	## ## but the macro /can/ be used recursively.
	## functions defined after the macro are not visible.
	## ## I think this is sensible... 
	EvalAst (transform 
		 `(let ,VAll (eval-binding ,VAll)
		      :,MacBody)
		 MEnv)
	EvalFn
	(begin
	 ##(io\format "EvalAst: \n~s\n" [(erl_pp\expr EvalAst)])
	 (fn (Ast)
		   (let {Result _} (scompile\eval_erl EvalAst [{VAllName Ast}] MEnv):
			Result)))
	DefAst {function Line MacName 1
			 (verl\clause [VAll] [] [`(begin ,MacBody)] Line MEnv)}
	:
	## the macro definition needs to be in meta and normal env
	(let* MacDef {EvalFn
		      [{ast DefAst}
		       {name MacName}
		       {args Args} 
		       {doc "A macro"}]}
	      MEnv (new-def MEnv macros Name  MacDef)
	      Env (new-def Env macros Name MacDef)
	      Env (verl\put_meta_env Env MEnv):
	      {10 Env}
	      )))


(def sp-defspecial (`(,_Car ,Name (;Args) ,VEnv: ;Body) Env):
  (let* Name (let (atom Name) Name: Name)
	MEnv (let {ok MEnv} (verl\get_meta_env Env): MEnv)
	Line (lineno)
	#the variable for the whole macro expression
	VAllName (gensym)
	VAll (var VAllName)
	#the variable for the environment during expansion
	#VEnv
	VEnvName (let (var Name) VEnv: Name) 
	#the actual name to define the macro function
	MacName (erlang\list_to_atom
		 (cat "$special$" (erlang\atom_to_list Name))) 
	MacBody (macro-arg-1 Args Body VAll)
	EvalAst (transform 
		 `(let ,VAll (eval-binding ,VAll)
		       ,VEnv (eval-binding ,VEnv)
		      :,MacBody)
		 MEnv)
	EvalFn
	(begin
	 ##(io\format "EvalAst: \n~s\n" [(erl_pp\expr EvalAst)])
	 (fn (Ast Env)
		   (let {Result _} (scompile\eval_erl EvalAst [{VAllName Ast}
							       {VEnvName Env}]
						      MEnv):
			Result)))
	DefAst {function Line MacName 1
			 (verl\clause [VAll VEnv] [] [`(begin ,MacBody)] Line MEnv)}
	:
	## the macro definition needs to be in meta and normal env
	(let* MacDef {EvalFn
		      [{ast DefAst}
		       {name MacName}
		       {args Args} 
		       {doc "A special form"}]}
	      MEnv (new-def MEnv specials Name  MacDef)
	      Env (new-def Env specials Name MacDef)
	      Env (verl\put_meta_env Env MEnv):
	      {10 Env}
	      )))


(def macro-aux-args (Blocks VAll):
  # auxiliary arguments that don't consume arguments.
  (foldl (fn ((block [Type|Spec]) Bindings)
	     (case Type
	       ('all [(>> Spec [AllArg] AllArg) VAll | Bindings])))
	 []
	 Blocks))

(def macro-arg-1 (Args Body VAll):
  # parse the required args
  (let* {RequiredArgs Blocks} (upto-block Args)
	{Blocks AuxBlocks} (lists\partition
			    (fn ((block [Type|_]))
				 # raise error if type not recognized
				 (case Type
				   ('pos true)
				   ('all false)))
			     Blocks)
	AuxBindings (macro-aux-args AuxBlocks VAll)
	VK (genvar)
	:
	(case Blocks
	  ([] `(let (paren [_Car ;RequiredArgs]) ,VAll
		    ;AuxBindings
		    : ;Body))
	  (_ `(let (paren [_Car ;RequiredArgs|,VK]) ,VAll
		   ;AuxBindings
		   :,(macro-arg-2 Blocks Body VK))
	     ))))

(def macro-arg-2 ([Block|Blocks] Body VK):
  # parse the pos arg-block if there's one
  (case Block
    ((block ['pos PosArg])
     (with-genvar VK2:
       `(let {,PosArg ,VK2} (serl\upto-block ,VK)
	   :,(macro-arg-3 Blocks Body VK2))
       ))
    (_ (macro-arg-3 [Block|Blocks] Body VK))))

(def macro-arg-3 ([] Body VK):
  # parse the block args
  # key & etc
  `(begin ,VK ;Body))


(def sp-block (`(,_Car ;[Es]) Env):
  (transform `(ls: ;Es) Env))

(def sp-brace (`(,_Car ;[Es]) Env): 
  (transform `(tuple: ;Es) Env))

# If E is if Ic_1 ; ... ; Ic_k end, where each Ic_i is an if clause then Rep(E) = {'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}.
(def sp-if (`(if ;Body) Env):
  (let Line (lineno):
       {if Line (if-clauses Body [] Line Env)}))

(def if-clauses (Tests Acc Line Env):
  (case Tests
    ([Guard Exp|Tests]
     (if-clauses Tests
		 [(verl\clause [] Guard [Exp] (ast-line Guard) Env)
		  |Acc]
		 Line Env))
    ([Exp]
     (reverse [(verl\clause [] 'true [Exp] (ast-line Exp) Env)
	       |Acc]))
    ([] (reverse Acc))))

# ## If E is case E_0 of Cc_1 ; ... ; Cc_k end, where E_0 is an expression and each Cc_i is a case clause then Rep(E) = {'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}.

(def sp-case (`(case ,E ;Cs) Env):
  (let Line (lineno)
       RE (transform E Env)
       RCs (map_env0 (fn (C) (case-clause C Env))
		     Cs
		     Env):
       {Env {case Line RE RCs}}))

# (def case-clause ((paren [P,(block Es)] L _Mod) Env):
#      ## ugh! Yuk. I need accessors to access the data of asts.
#      ## TODO I would prefer (paren [P|Es]: L _Mod). 
#      (clause [P] [] Es L Env))

(def case-clause (`(,P: ;Es) Env):
  (verl\clause [P] [] Es (ast-line P) Env))

# (def case-clause (`(,P: ;Es) Env):
#      (let (L (ast-line Es)):
#        (clause [P] [] Es L Env)))

# (def clause (Ps Gs Es L Env):
#      (let ({Env RPs} (verl\patterns Ps Env)):
#        {Env {clause L RPs
# 		    ## an erlang clause takes a guard sequence
# 		    ## a guard sequence is a list of guard tests
# 		    ## (we support only one guard sequence)
# 		    (verl\guards Gs Env ~>> {_ RGs} RGs)
# 		    (transform_each Es Env ~>> {_ REs} REs)}}
#        ))

## 4.6

# (def guards (GuardTests Env):
#      (transform_each GuardTests Env))

## If E is fun Fc_1 ; ... ; Fc_k end where each Fc_i is a function clause then Rep(E) = {'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}.

(def sp-fn (`(fn (;Args) ;Es) Env):
  (let Env (scompile\lexical_shadow Env vars []):
    {fun (lineno)
	 {clauses (verl\clause Args [] Es (lineno) Env)}}))

(def mac->> (`(>> ,Val ,Pattern ;Es)):
  `(let ,Pattern ,Val: ;Es))

# (def sp-fn (`(fn (;Args): ;Es) Env):
#      {Env {fun (lineno)
# 	       {clauses (verl\clause Args [] Es (lineno) Env ~at 2)}}})

# If E is E_1 Op E_2, where Op is a binary operator, then Rep(E) = {op,LINE,Op,Rep(E_1),Rep(E_2)}.

# (def op-ast (Op E1 E2 Env):
#   {Env {op (ast-line E1)
# 	   Op
# 	   (transform E1 Env ~>> {_ RE1} RE1)
# 	   (transform E2 Env ~>> {_ RE2} RE2)}})

# (def sp-> (`(> ,E1 ,E2) Env):
#   (op-ast > E1 E2 Env))

# (def sp-== (`(== ,E1 ,E2) Env):
#   (op-ast == E1 E2 Env))

# (def sp-+ (`(+ ,E1 ,E2) Env):
#   (op-ast + E1 E2 Env))



(def ast-line (Ast): (erlang\element 2 Ast))

(def upto-block (Es):
  (let {UpToFirstBlock Rest} (lists\splitwith
			      (fn (E)
				  (case E
				    ((block _) false)
				    (_ true)))
			      Es):
       {UpToFirstBlock Rest}
       ))