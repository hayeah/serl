## make sure I can change the AST representation whenver I feel like it.

## each custom namespace probably needs to define a set of pseudo special forms
## export-<NS>
## import-<NS>
## output-<NS>

(module serl)

(import scompile
	error
	lineno
	curmod
	transform
	transform_each
	map_env0
	genvar
	gensym
	)

(import lists
	map
	foldl
	foldr
	reverse
	member)

## verl's meta-module doesn't support import.
### this is a special case
# (import verl clause) 
#(importm verl ...)

(export ast-tag ast-line ast-mod ast-data
	upto-block
	)

(export sp-block sp-brace
	sp-fn
	sp-call
	sp-let
	sp-lsc
	sp-case
	sp-if
	sp-def
	sp-defm
	sp-defspecial
	
	sp-import-from

	)

(export mac-let*
	mac->>
	mac-with-genvar
	)

(export
  sp-+
  sp--
  sp-*
  sp-/
  sp-==
  sp-not
#  sp-<
# sp->
 )


## (export "sp-.*")
## (export "mac-.*")

##################################################
# 1. Environment
#
# Just support functions & macros/specials for the moment.

# (import-from mod (macros ...) (functions ...))

#\import-from
(def sp-import-from (`(,_ ,Mod ;Specs) Env):
  (let (atom Mod) Mod:
       {2 (env-import Env Mod Specs)}
       ))

(def env-import (Env Mod Specs):
  (case Specs
    ([] Env)
    ([`(,Type ;Names)|Specs]
     (let Names (lsc (atom A) Names: A)
	  (atom Type) Type:
	  (lists\foreach
	   (fn (Name)
	       (case (scompile\lookup Env Type {(curmod) Name})
		 ({ok _} (error "Import conflict: ~p:~p" [Mod Name]))
		 (_ ok)))
	   Names)
	  #TODO allow importing functions from not yet loaded modules
#     Env2=try env:import(Env,Mod,functions,Imports)
# 	 catch no_imports ->
# 		 env:assoc_put(
# 		   Env,
# 		   [imports,Mod,functions],
# 		   [{F,{Mod,F}} || F <- Imports]) 
# 	 end,
	  (env-import (env\import Env Mod Type Names) Mod Specs)
	  ))))

# (export-from (functions a b c) (macros c d e)) ## =>
# (toplevel
#  (functions-export a b c)
#  (macros-export c d e))

# (def sp-export-from (`(,_ ;Specs)):
#   )

# ?defsp('__sp_export',Atoms) ->
#     Line=lineno(),
#     Mod=curmod(),
#     Names=[Name || ?ast_atom3(_,_,Name) <- Atoms],
#     ?lazyout(Env2,export_attribute(Names,Line,Env2)),
#     {?header_sec,
#      env:assoc_append(
#        Env,
#        [exports,functions],
#        [{Name,{Mod,Name}} || Name <- Names])}.

# %% (export a b c)
# export_attribute(Names,Line,Env) ->
#     Exports=
# 	[begin
# 	     {Name,def_info(Env,functions,Name,arities)}
# 	 end 
# 	 || Name <- Names],
#     {attribute,Line,export,
#      [{Name,Arity} ||
# 	 {Name,Arities} <- Exports,
# 	 Arity <- Arities]}.

# (defm importm (Mod :pos Names)
#   `(import-from ,Mod (macros ;Names)))

# (defm import (Mod :pos Names)
#   `(import-from ,Mod (functions ;Names)))


(def new-def (Env NSType Name Def):
  (let Defined (env\assoc Env [definitions NSType Name]):
       (if Defined (error "%s already defined in %s" [Name NSType])
	   (env\assoc_put Env [definitions NSType Name] Def)
	   )))

# (def def-info (Env NSType Name Key):
#   (case (env\assoc Env [definitions NSType Name])
#     ({ok Def} (proplists\lookup Key (erlang\element 2 Def) ~case
# 				({_ Val} Val)
# 				(none (error "Unknown property ~p of function ~p"
# 					     [Key Name]))))
#     (_ (error "Undefined function: ~p" [Name]))))


##################################################
# 2. Definitions

#\def
(def sp-def (`(,_Car ,(atom Name) (;Args) ;Es) Env):
  (let* Line (lineno)
	Arity (erlang\length Args)
	[(block Body)|Options] (reverse Es)
	Options (lsc (block [(atom Type)|Spec]) Options: {Type Spec})
	Doc (proplists\lookup doc Options ~case
			      (none "No doc")
			      ({doc [(string Doc)]} Doc))
	EvalFlag (proplists\lookup eval Options ~case
				   (none false)
				   ({eval []} true))
	DefAst {function Line Name Arity
			 [(verl\clause Args [] Body Line Env)]}
	EvalVarName (gensym)
	EvalVar (var EvalVarName)
	## Note that the it expects compiler to pass in the args in a list.
	EvalAst (if EvalFlag (transform
			      `(case (eval-binding ,EvalVar)
				 ([;Args] ;Body))
			      Env)
		    false)
	## TODO support multiple arities
	EvalFn (if EvalFlag (fn (Args)
				(scompile\eval_erl EvalAst [{EvalVarName Args}] Env ~>>
						   {Result _} Result))
		   {(curmod) Name})
	:
	(verl\output DefAst)
	{10 (new-def Env functions Name
		     {EvalFn
		      [{ast DefAst}
		       {doc Doc}
		       {eval EvalFlag}
		       {arities [Arity]}]})}
	))


#\defm
(def sp-defm (`(,_Car ,Name (;Args) :;Body) Env):
  (let* Name (let (atom Name) Name: Name)
	Line (lineno)
	#the variable for the whole macro expression
	VAllName (gensym)
	VAll (var VAllName)
	#the actual name to define the macro function
	MacName (erlang\list_to_atom
		 (cat "$mac$" (erlang\atom_to_list Name))) 
	MacBody (macro-arg-1 Args Body VAll)
	## the macro function interprets the erl-ast of the macro definition
	## the macro function closes over the current  meta-environment.
	## the macro is not visible to its own definition.
	## ## but the macro /can/ be used recursively.
	## functions defined after the macro are not visible.
	## ## I think this is sensible... 
	EvalAst (transform 
		 `(let ,VAll (eval-binding ,VAll)
		      :,MacBody)
		 Env)
	EvalFn
	(begin
	 ##(io\format "EvalAst: \n~s\n" [(erl_pp\expr EvalAst)])
	 (fn (Ast)
	     (scompile\eval_erl EvalAst [{VAllName Ast}] Env ~>>
				{Result _} Result)
	     ))
	DefAst {function Line MacName 1
			 (verl\clause [VAll] [] [`(begin ,MacBody)] Line Env)}
	:
	## the macro definition needs to be in meta and normal env
	{10 (new-def Env macros Name
		     {EvalFn
		      [{ast DefAst}
		       {name MacName}
		       {args Args} 
		       {doc "A macro"}]})}))


#\defspecial
(def sp-defspecial (`(,_Car ,Name (;Args) ,VEnv: ;Body) Env):
  (let* Name (let (atom Name) Name: Name)
	Line (lineno)
	#the variable for the whole macro expression
	VAllName (gensym)
	VAll (var VAllName)
	#the variable for the environment during expansion
	#VEnv
	VEnvName (let (var Name) VEnv: Name) 
	#the actual name to define the macro function
	MacName (erlang\list_to_atom
		 (cat "$special$" (erlang\atom_to_list Name))) 
	MacBody (macro-arg-1 Args Body VAll)
	EvalAst (transform 
		 `(let ,VAll (eval-binding ,VAll)
		       ,VEnv (eval-binding ,VEnv)
		      :,MacBody)
		 Env)
	EvalFn
	(begin
	 ##(io\format "EvalAst: \n~s\n" [(erl_pp\expr EvalAst)])
	 (fn (Ast Env)
		   (let {Result _} (scompile\eval_erl EvalAst [{VAllName Ast}
							       {VEnvName Env}]
						      Env):
			Result)))
	DefAst {function Line MacName 1
			 (verl\clause [VAll VEnv] [] [`(begin ,MacBody)] Line Env)}
	:
	## the macro definition needs to be in meta and normal env
	{10 (new-def Env specials Name
		     {EvalFn
		      [{ast DefAst}
		       {name MacName}
		       {args Args} 
		       {doc "A special form"}]})}
	))


(def macro-aux-args (Blocks VAll):
  # auxiliary arguments that don't consume arguments.
  (foldl (fn ((block [Type|Spec]) Bindings)
	     (case Type
	       ('all [(>> Spec [AllArg] AllArg) VAll | Bindings])))
	 []
	 Blocks))

(def macro-arg-1 (Args Body VAll):
  # parse the required args
  (let* {RequiredArgs Blocks} (upto-block Args)
	{Blocks AuxBlocks} (lists\partition
			    (fn ((block [Type|_]))
				 # raise error if type not recognized
				 (case Type
				   ('pos true)
				   ('all false)))
			     Blocks)
	AuxBindings (macro-aux-args AuxBlocks VAll)
	VK (genvar)
	:
	(case Blocks
	  ([] `(let (paren [_Car ;RequiredArgs]) ,VAll
		    ;AuxBindings
		    : ;Body))
	  (_ `(let (paren [_Car ;RequiredArgs|,VK]) ,VAll
		   ;AuxBindings
		   :,(macro-arg-2 Blocks Body VK))
	     ))))

(def macro-arg-2 ([Block|Blocks] Body VK):
  # parse the pos arg-block if there's one
  (case Block
    ((block ['pos PosArg])
     (with-genvar VK2:
       `(let {,PosArg ,VK2} (serl\upto-block ,VK)
	   :,(macro-arg-3 Blocks Body VK2))
       ))
    (_ (macro-arg-3 [Block|Blocks] Body VK))))

(def macro-arg-3 ([] Body VK):
  # parse the block args
  # key & etc
  `(begin ,VK ;Body))



##################################################
# 3. Binding Forms

#\let
(def mac-let* (`(,_ ;Form)):
  (let {Bindings [(block Body)]} (upto-block Form):
       (case Bindings
	 ([] `(begin ;Body))
	 ([Pattern Value|Bindings] `(let ,Pattern ,Value: (let* ;Bindings: ;Body))))))

(def sp-let (`(let ;Es) Env):
  (let* Line (lineno)
	{Bindings [(block Body)]} (upto-block Es)
	{Patterns Assignments} (let-bindings Bindings [] [])
	Env2 (verl\binds Patterns (scompile\lexical_shadow Env vars []))
	Assignments (map
		     (fn ({P V}):
			 {match (element 2 P)
				(verl\gen_pat P Env2) # pattern generated with new bindings
				(transform V Env)} # value evaluated with old environment
			 )
		     
		     Assignments):
	{block Line (cat Assignments (transform_each Body Env2))}))

(def let-bindings (Bindings Patterns Assignments):
     (case Bindings
       ([]: {(reverse Patterns) (reverse Assignments)})
       ([Pattern Value|Bindings]:
	(let-bindings Bindings [Pattern|Patterns] [{Pattern Value}|Assignments]))))

(def mac->> (`(>> ,Val ,Pattern ;Es)):
  `(let ,Pattern ,Val: ;Es))


#\with-genvar
(def mac-with-genvar (`(,_ ;Form)):
  (let {Vars [BodyBlock]} (upto-block Form):
       `(let ;(lists\foldl
	       (fn (Var Acc) [Var '(scompile\genvar)|Acc])
	       []
	       Vars)
	  ,BodyBlock
	  )))

# ## If E is case E_0 of Cc_1 ; ... ; Cc_k end, where E_0 is an expression and each Cc_i is a case clause then Rep(E) = {'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}.

#\case
(def sp-case (`(case ,E ;Cs) Env):
  (let Line (lineno):
       {case Line
	 (transform E Env)
	 (lsc `(,P ;Es) Cs:
	      (verl\clause [P] [] Es (ast-line P) Env))}
       )) 

# If E is a list comprehension [E_0 || W_1, ..., W_k], where each W_i is a generator or a filter, then Rep(E) = {lc,LINE,Rep(E_0),[Rep(W_1), ..., Rep(W_k)]}. For Rep(W), see below.

# When W is a generator or a filter (in the body of a list or binary comprehension), then: 
# If W is a generator P <- E, where P is a pattern and E is an expression, then Rep(W) = {generate,LINE,Rep(P),Rep(E)}. 
# If W is a generator P <= E, where P is a pattern and E is an expression, then Rep(W) = {b_generate,LINE,Rep(P),Rep(E)}. 
# If W is a filter E, which is an expression, then Rep(W) = Rep(E).

#\lsc
(def sp-lsc (`(,_ ;Form) Env):
  (let* Line (lineno)
	{Qualifiers [(block Body)]} (upto-block Form)
	{Env RWs} (lsc-bindings Env Qualifiers [])
	:
	{lc Line
	    (transform `(begin ;Body) Env)
	    RWs}
	))

(def lsc-bindings (Env Qs Acc):
  (case Qs
    ([] {Env (reverse Acc)})
    (['if Filter|Qs] (lsc-bindings Env Qs [(transform Filter Env)|Acc]))
    ([Pattern Generator|Qs]
     (let Env2 (verl\bindmac Pattern Env):
	  (lsc-bindings Env2 Qs [{generate (ast-line Pattern)
					   (verl\gen_pat Pattern Env2)
					   (transform Generator Env)}
				 |Acc])
	  ))))





# If E is fun Fc_1 ; ... ; Fc_k end where each Fc_i is a function clause then Rep(E) = {'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}.
# (fn (A B) ...)
# (fn 3 ...) == (fn (V1 V2 V3) ...)

# If E is fun Name / Arity, then Rep(E) = {'fun',LINE,{function,Name,Arity}}. 
# If E is fun Module:Name/Arity, then Rep(E) = {'fun',LINE,{function,Module,Name,Arity}}.
# (fn foo 3)


#\fn 
(def sp-fn (`(fn (;Args) ;Es) Env):
  (let Env (scompile\lexical_shadow Env vars []):
    {fun (lineno)
	 {clauses (verl\clause Args [] Es (lineno) Env)}}))


# %%  If E is E_m:E_0(E_1, ..., E_k), then Rep(E) = {call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}. 
# (call Em\E0 ...)

# %%  If E is E_0(E_1, ..., E_k), then Rep(E) = {call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}.
# (call E0 ...)

#\call 
(def sp-call (`(,_ ,Fn ;Args) Env):
  (case Fn
    (`{,M ,A} (remote-call M A Args Env))
    ((atom A) (let* M (ast-mod Fn)
		    # check to see if the atom is from the source or from macro.
		    FromSource (== M (curmod)): 
		    (if FromSource
			(case (scompile\lookup_imports Env functions A)
			  # atom is associated with import
			  ({ok {{M A}}} (remote-call (atom M) (atom A) Args Env))
			  # atom is assumed to be local call
			  (R (io\format "Result: ~p\n Env: ~p\n" [R Env])
			     (local-call Fn Args Env)))
			# atom is not from the source, so interpret as remote
			(remote-call (atom M) Fn Args Env))
		   ))
    (_ (local-call Fn Args Args))))

(def local-call (A Args Env):
  {call (ast-line A) (transform A Env) (transform_each Args Env)})

(def remote-call (M A Args Env):
  (let L (ast-line M):
       {call L
	     {remote L (transform M Env) (transform A Env)}
	     (transform_each Args Env)}))

##################################################
# .Misc

(def sp-block (`(,_Car ;[Es]) Env):
  (transform `(ls: ;Es) Env))

(def sp-brace (`(,_Car ;[Es]) Env): 
  (transform `(tuple: ;Es) Env))

# If E is if Ic_1 ; ... ; Ic_k end, where each Ic_i is an if clause then Rep(E) = {'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}.

##################################################
# .Control Forms

(def sp-if (`(if ;Body) Env):
  (let Line (lineno):
       {if Line (if-clauses Body [] Line Env)}))

(def if-clauses (Tests Acc Line Env):
  (case Tests
    ([Guard Exp|Tests]
     (if-clauses Tests
		 [(verl\clause [] Guard [Exp] (ast-line Guard) Env)
		  |Acc]
		 Line Env))
    ([Exp]
     (reverse [(verl\clause [] 'true [Exp] (ast-line Exp) Env)
	       |Acc]))
    ([] (reverse Acc))))

# (def sp-toplevel (`(_ ;Forms) Env)
#   (map_env0 (fn transform 2) Forms Env Env))

# (def guards (GuardTests Env):
#      (transform_each GuardTests Env))

# If E is E_1 Op E_2, where Op is a binary operator, then Rep(E) = {op,LINE,Op,Rep(E_1),Rep(E_2)}.

##################################################
# .Operators

# Term Comparisons
# == 	equal to 
# /= 	not equal to 
# =< 	less than or equal to 
# < 	less than 
# >= 	greater than or equal to 
# > 	greater than 
# =:= 	exactly equal to 
# =/= 	exactly not equal to


# Arithmetic Ops
# op 	Description 	Argument type 
# + 	unary + 	number 
# - 	unary - 	number 
# + 	  	number 
# - 	  	number 
# * 	  	number 
# / 	floating point division 	number 
# bnot 	unary bitwise not 	integer 
# div 	integer division 	integer 
# rem 	integer remainder of X/Y 	integer 
# band 	bitwise and 	integer 
# bor 	bitwise or 	integer 
# bxor 	arithmetic bitwise xor 	integer 
# bsl 	arithmetic bitshift left 	integer 
# bsr 	bitshift right 	integer

# Boolean Ops

# not 	unary logical not 
# and 	logical and 
# or 	logical or 
# xor 	logical xor

# (def-ops
#     (binary-nested + - * /)
#     (binary == /= =< < >= >) 
#   (binary div rem bnot band bor bxor bsl bsr)
#   #(binary === /==) # defined separately
#   (unary not and or xor))

# (def-ops
#     :binary-nested
#     + - * /
#     :binary
#      == /= =< < >= >
#      div rem
#      bnot band bor bxor bsl bsr
#      # === /== # defined separately
#      :unary
#       not and or xor
#   )

#If E is Op E_0, where Op is a unary operator, then Rep(E) = {op,LINE,Op,Rep(E_0)}.

#If E is E_1 Op E_2, where Op is a binary operator, then Rep(E) = {op,LINE,Op,Rep(E_1),Rep(E_2)}.

(def nest-bin-op (Op [Arg1 Arg2|Args] Env):
  # (Op A B ...) => (Op (Op A B) C ...)
  # (- A B C ...) => (- (- A B) C ...)
  (foldl (fn (Arg Exp)
	     {op (ast-line Arg) Op
		 Exp
		 (transform Arg Env)})
	 {op (lineno) Op (transform Arg1 Env) (transform Arg2 Env)}
	 Args))

(def bin-op (Op [Arg1 Arg2] Env):
  {op (ast-line Arg1)
      Op
      (transform Arg1 Env)
      (transform Arg2 Env)})

(def una-op (Op [Arg1] Env):
  {op (ast-line Arg1)
      Op
      (transform Arg1 Env)})

# (def op-ast (Op E1 E2 Env):
#   {Env {op (ast-line E1)
# 	   Op
# 	   (transform E1 Env ~>> {_ RE1} RE1)
# 	   (transform E2 Env ~>> {_ RE2} RE2)}})


(def sp-+ (`(+ ;Args) Env):
  (nest-bin-op + Args Env))

(def sp-- (`(- ;Args) Env):
  (nest-bin-op - Args Env))

(def sp-/ (`(/ ;Args) Env):
  (nest-bin-op / Args Env))

(def sp-* (`(* ;Args) Env):
  (nest-bin-op * Args Env))

(def sp-== (`(== ;Args) Env):
  (bin-op == Args Env))

(def sp-not (`(not ;Args) Env):
  (una-op not Args Env))


##################################################
# .Helper


# (def clause (Ps G Es Line Env):
#   (let {Env RPs} (verl\patterns Ps Env)
# 	  :
#        {clause Line (transform_each Es Env2)
# 	       ## an erlang clause takes a guard sequence
# 	       ## a guard sequence is a list of guard tests
# 	       ## (we support only one guard sequence)
# 	       (verl\guards Gs Env ~>> {_ RGs} RGs)
# 	       (transform_each Es Env ~>> {_ REs} REs)}
#        ))

# clause(Ps,G,Es,Line,Env) ->
#     %% A <guard> is a list of <guard-test>
#     {Env2,RPs}=patterns(Ps,scompile:lexical_shadow(Env,vars,[])),
#     REs=transform_each(Es,Env2), 
#     GuardSequence=
# 	case G of
# 	    [] -> [];
# 	    _ -> [[guard(G,Env2)]]
# 	end,
#     {clause,Line, RPs, GuardSequence, REs}.

(def ast-tag (Ast): (erlang\element 1 Ast))
(def ast-line (Ast): (erlang\element 2 Ast))
(def ast-mod (Ast): (erlang\element 3 Ast))
(def ast-data (Ast): (erlang\element 4 Ast))

(def upto-block (Es):
  (let {UpToFirstBlock Rest} (lists\splitwith
			      (fn (E)
				  (case E
				    ((block _) false)
				    (_ true)))
			      Es):
       {UpToFirstBlock Rest}
       ))